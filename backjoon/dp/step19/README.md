# [점프](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step19/src/Main.java)
N×N 게임판에 수가 적혀져 있다. 이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.<br/>
<br/>
각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다. 반드시 오른쪽이나 아래쪽으로만 이동해야 한다. 0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다. 한 번 점프를 할 때, 방향을 바꾸면 안 된다. 즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.<br/>
<br/>
가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 프로그램을 작성하시오.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1890)) <br/>

## 해법
* `N` 크기만큼 배열 `dp`를 생성한다.
* `NxN` 크기만큼 반복문을 돌면서 최종도착지점에 도착하는 경우의 수를 누적합 진행한다.
  * `board[x][y]`에 이동가능한 횟수가 `0` 이하라면 해당 위치 탐색은 종료한다.
  * 탐색하려는 `{x,y}` 위치의 `dp` 값이 `0` 이라면 이동할 수 없는 위치이기 때문에 탐색을 종료한다.
* `dp`에 값을 넣는 점화식은 아래와 같다.
  * 오른쪽 -> `dp[r][y] += dp[x][y]`
  * 아래   -> `dp[x][c] += dp[x][y]`
    * `r = x + board[x][y], c = board[x][y]` 이동가능한 최대 좌표까지 이동했을 때 `r || c` 가 `N`의 크기를 벗어나지 않았다면 이동한 해당 위치에 이동한 카운트를 누적합을 진행한다.

## 핵심
* 지문에서 보면 알다시피 `{오른쪽, 아래}` 두 가지 방법 밖에 이동할 수 없으므로 `DFS, BFS`로 탐색하는 것 보다 `DP`를 활용하여 문제를 풀어나가는게 좋다.
  * `{오른쪽, 아래}`로만 이동이 가능하다면, 이동경로를 되돌아가는 경우도 생기지않고 중복 이동경로를 쉽게 제거할 수 있다.

## 문제점
