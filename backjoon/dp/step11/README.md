# [LCS 2](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step11/src/Main.java)
LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.<br/>
<br/>
예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/9252)) <br/>

## 해법
* 문자열 두 개를 비교해서 가장 긴 LCS를 구해야하기 때문에 2 차원 `dp`를 만든다.
  * `[문자열 A][문자열 B]`로 `[i][j]`는 `A의 앞 i글자(A[0..i-1])와 B의 앞 j글자(B[0..j-1])`사이의 LCS 값을 저장해야한다.
* 배열에 저장할 점화식은 두 문자열이 같을땐 `문자열 a[i - 1] == 문자열 b[j - 1] -> dp[i][j] = dp[i - 1][j - 1] + 1` 문자열이 같지 않을때는 `dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`
  * 문자열이 같을때는 만약 `a[2] = A, b[3] = A`와 같이 문자가 같다면 `a` 문자에 `[2] = A`를 제외한 문자 위치 + `b` 문제에 `[3] = A`를 제외한 문자 위치에 `A`라는 문자를 더 긴 문자열에 `+ 1` 해주는 것 과 같다.
  * 문자열이 같지 않을때는 `a[3] = C, b[2] = B`와 같이 문자가 다르다면  `a` 문자열에 `[2] = B` 문자를 제외한 `b` 문자열과 비교해서 구한 LCS 값과 `b` 문자열에 `[3] = C`를 제외한 `a` 문자열과 비교해서 구한 LCS 값 중 더 큰 값을 저장한다.
* 마지막으로 LCS 문자열을 구한다.

## 핵심
* 2 차원 배열에 행에는 `A` 문자 열에는 `B` 문자를 각각 위치해 범위 별 LCS 값을 누적합 진행이 중요하다.