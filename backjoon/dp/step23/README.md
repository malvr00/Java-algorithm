# [내려가기](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step22/src/Main.java)
N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다.<br/>
<br/>
먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다. 바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 이 제약 조건을 그림으로 나타내어 보면 다음과 같다.<br/>
<br/>
별표는 현재 위치이고, 그 아랫 줄의 파란 동그라미는 원룡이가 다음 줄로 내려갈 수 있는 위치이며, 빨간 가위표는 원룡이가 내려갈 수 없는 위치가 된다. 숫자표가 주어져 있을 때, 얻을 수 있는 최대 점수, 최소 점수를 구하는 프로그램을 작성하시오. 점수는 원룡이가 위치한 곳의 수의 합이다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2096)) <br/>

## 해법
* 이 문제는 최소, 최대 두 가지 경우를 구해야하기 때문에 `maxDp[N][3], minDp[N][3]` 두 개의 배열을 생성한다.
* 먼저 `0` 번 째 줄은 직관적으로 알 수 있으므로 수동으로 값을 초기에 세팅한다.
* 그 다음 반복문을 `1 ~ N - 1` 까지 반복한다.
* 반복문을 돌면서 점화식을 실행하면되는데 점화식은 아래와 같다.
  * `dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]) + board[i][0] || min(dp[i - 1][0], dp[i - 1][1]) + board[i][0]`
    * `0` 번 위치에 갈 수 있는 방법은 `0, 1` 번 방법 밖에 없다.
  * `dp[i][1] = max(dp[i - 1][0], max(dp[i - 1][1], dp[i - 1][2])) + board[i][1] || min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + board[i][1]`
    * `1` 번 위치에 갈 수 있는 방법은 `0, 1, 2` 모든 방법이 가능하기 때문에 모든 경로 중 최대, 최소 값을 저장한다.
  * `dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + board[i][2] || min(dp[i - 1][1], dp[i - 1][2]) + board[i][2]`
    * `2` 번 위치에 갈 수 있는 방법은 `1, 2` 번 방법 밖에 없다.
* 배열 마지막 행 까지 모든 값이 누적되었으면 두 배열에 마지막 행 중 최소, 최대 값을 찾아 출력한다.

## 핵심
* `i` 위치에 도착하는 방법을 배열로 쪼개서 문제를 해결하면 쉽게 접근할 수 있다.

## 문제점
