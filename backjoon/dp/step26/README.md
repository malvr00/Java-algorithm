# [고층 빌딩](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step26/src/Main.java)
상근이가 살고있는 동네에는 빌딩 N개가 한 줄로 세워져 있다. 모든 빌딩의 높이는 1보다 크거나 같고, N보다 작거나 같으며, 같은 높이를 가지는 빌딩은 없다. 상근이는 학교 가는 길에 가장 왼쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았고, 집에 돌아오는 길에는 가장 오른쪽에 서서 빌딩을 몇 개 볼 수 있는지 보았다.<br/>
<br/>
상근이는 가장 왼쪽과 오른쪽에서만 빌딩을 봤기 때문에, 빌딩이 어떤 순서로 위치해있는지는 알 수가 없다.<br/>
<br/>
빌딩의 개수 N과 가장 왼쪽에서 봤을 때 보이는 빌딩의 수 L, 가장 오른쪽에서 봤을 때 보이는 빌딩의 수 R이 주어졌을 때, 가능한 빌딩 순서의 경우의 수를 구하는 프로그램을 작성하시오.<br/>
<br/>
예를 들어, N = 5, L = 3, R = 2인 경우에 가능한 빌딩의 배치 중 하나는 1 3 5 2 4이다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1328)) <br/>

## 해법 1
* 이 문제는 `건물의 수 = N, 왼쪽에서 보이는 건물 수 = L, 오른쪽에서 보이는 건물 수 = R` 형식으로 `dp[N][L][R]` 형태의 배열을 만든다.
  * 이러한 형태로 하는 이유는 `dp[2][2][1]` 일 때 건물의 수 가 2 일 때 왼쪽에서 보이는 건물 수는 2, 오른쪽에서 보이는 건물 수는 1 을 의미한다.  
* `N * L * R` 형태로 반복문을 돌면서 점화식을 실행한다.
* 점화식은 아래와 같다. 
  * `dp[n][l][r] = dp[n - 1][l - 1][r]`
    * `n = 4, l = 2, r = 2` 일 때 건물 3 개를 사용해서 왼쪽에서 보이는 건물 위치는 `4 2 3 ([3][1][2])` 형태가 되는데 왼쪽에 건물을 하나를 추가하면 `1 4 2 3`로 완성 할 수 있다.
  * `dp[n][l][r] = dp[n - 1][l][r - 1]`
    * `n = 4, l = 2, r = 2` 일 때 건물 3 개를 사용해서 오른쪽에서 보이는 건물 위치는 `3 2 4 ([3][2][1])` 형태가 되는데 왼쪽 건물을 세우는 방법과 같이 이번에는 오른쪽에 건물 하나만 추가하면 `3 2 4 1` 형태로 `[4][2][2]`를 완성할 수 있다.
  * `dp[n][l][r] = dp[n - 1][l][r] * (n - 2)`
    * `n = 4, l = 2, r = 2` 일 때 건물 위치는 `3 4 2 ([3][2][2])` 형태로 중간에 건물을 세우는 방식인데 왼쪽과 오른쪽에 건물을 세우는 방식과는 조금 다르게 `{3 1 4 2}, {3 4 1 2}` 형태로 두 가지로 완성 수 있다. 그리고 `n - 1 건물로 배치할 때 중간에 건물을 세울 수 없는 경우 = 0`과 `중간에 세우는 건물 수 = n - 2`를 마지막에 곱해서 처리한다.
      * `n - 2`는 양 끝 건물을 뺀 중간에 배치 가능한 빌딩의 수 이다.
* 위 점화식 세 가지 방식을 모두 더 하면 해당 `[n][l][r]` 위치에 건물을 배치하는 경우의 수가 모두 저장된다.

## 핵심
* 배열의 인덱스 정의를 잘 해야 쉽게 접근할 수 있다.

## 문제점
