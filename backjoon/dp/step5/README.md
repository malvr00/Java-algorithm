# [계단 오르기](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step5/src/Main.java)
계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.<br/>
계단 오르는 데는 다음과 같은 규칙이 있다.<br/>
<br/>
계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.<br/>
연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.<br/>
마지막 도착 계단은 반드시 밟아야 한다.<br/>
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.<br/>
<br/>
각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2579)) <br/>

## 해법
* 계단 수를 입력 받은 `N + 1` 크기 만큼의 점수를 저장할 배열 `dy`를 만든다.
  * `dy[1]`과 `dy[2]`은 즉 첫 번째 계단과 두 번째 계단은 쉽게 값을 구할 수 있으므로 계단 점수 배열 `values[0]` 을 `dy[1]`에 `values[0] + values[1]`은 `dy[2]`에 초기화 해준다.
* 다음 `N` 길이 만큼 값을 누적해야하는데, 3 번 연속으로 계단을 밟는 상황만 유의해서 점화식을 만든다.
  * 점화식은 다음과 같다. `dy[i] = max(dy[i - 2] + values[i - 1], dy[i - 3] + values[i - 2] + values[i - 1])`
    * `dy[i - 2] + values[i - 1]`은 만약 세 번째 계단일 경우 첫 번째 계단을 밟고 세 번째 계단으로 오는 경우
    * `dy[i - 3] + values[i - 2] + values[i - 1]`은 이제 연속 세 번 계단 밟는걸 제외한 값이다. 이 식을 뜯어보면 다음과 같다. 
      * `dy[i - 1]`로 바로 계산하면 `dy[i - 1]`의 값에는 바로 직전의 계단을 밟고 올라올 수 있는 상황이 있어서 사용할 수 없다.
      * `dy[i - 2]`를 사용하면 될 것 같지만 `i - 1` 즉 현재 계단에서 바로 전 계단을 밟고 올라와야 누적 점수가 더 높은 상황이 발생할 수 있어서 사용할 수 없다.
      * 그래서 결국 바로 전 단계의 계단을 밟고`(values[i - 2])` 3 번 연속해서 밟을 수 없으므로 이전 계단에서 한 칸 계단을 점프 뛴 누적 점수`(dy[i - 3])`를 활용해서 오는 경우로 점수를 계산해야한다.
* `N`이 `0 ~ 1` 인 경우만 주의한 후 정답인 `dy[N]`을 반환한다.

## 핵심
* 3 번 연속해서 계단을 밟는 경우를 주의해야한다.
* 현재 내가 서있는 계단 위치의 전 계단을 밟고 올라왔을 때 점수가 2 단계 아래의 계단을 밟고 올라오는 경우보다 더 점수가 높을 수 있는 점을 유의해야한다.

## 문제점
