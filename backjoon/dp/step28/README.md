# [구간 나누기](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step28/src/Main.java)
N(1 ≤ N ≤ 100)개의 수로 이루어진 1차원 배열이 있다. 이 배열에서 M(1 ≤ M ≤ ⌈(N/2)⌉)개의 구간을 선택해서, 구간에 속한 수들의 총 합이 최대가 되도록 하려 한다. 단, 다음의 조건들이 만족되어야 한다.<br/>
<br/>
1. 각 구간은 한 개 이상의 연속된 수들로 이루어진다.
2. 서로 다른 두 구간끼리 겹쳐있거나 인접해 있어서는 안 된다.
3. 정확히 M개의 구간이 있어야 한다. M개 미만이어서는 안 된다.
<br/>
N개의 수들이 주어졌을 때, 답을 구하는 프로그램을 작성하시오.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2228)) <br/>

## 해법
* `원소의 개수 = N, 배열의 구간 = M`이므로 배열 `dp[N + 1][M + 1]`을 만든다.
  * `[i] = k...i 까지 구간, [j] = 선택한 배열 구간`
* 구간에 대한 누적합을 활용해야 하기 때문에 원소의 값을 구간별로 누적합한다. `sums[i] = sums[i - 1] + scores[i - 1]`
  * `sums[i] = 1...i` 까지의 합
* `N^2 * M` 반복문을 돌면서 점화식을 실행한다.
* 점화식은 아래와 같다.
  * `dp[i][j] = dp[i - 1][j]`
    * `i - 1` 하는 이유는 최적의 값이 `i` 원소 이전에 구해줬을 수도 있기 때문에 전달 역할을 한다.
  * `if(k - 2 >= 0) val = dp[k - 2][j - 1]; else val == j - 1 == 0 ? 0 : ENF`
    * `k...i` 구간을 선택하고 추가로 구간을 선택해야 한다면 선택하는 구간을 `1...k-2`로 선택한다. 그 값이 `val`이 된다.
    * `ENF` 값은 구간 값을 구할 수 없는 불가능한 영역으로 원소의 값이 `ENF` 일 경우는 전부 탐색에서 제외한다.
  * `dp[i][j] = max(dp[i][j], val + sums[i] - sums[k - 1])`
    * 마지막으로 선택한 구간들 중 가장 큰 값을 저장한다.

## 핵심
* 배열의 인덱스 정의가 중요하고, 최적의 해를 연결해주는게 중요하다.

## 문제점
