# [행렬 곱셈 순서 ](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step10/src/Main.java)
크기가 N×M인 행렬 A와 M×K인 B를 곱할 때 필요한 곱셈 연산의 수는 총 N×M×K번이다. 행렬 N개를 곱하는데 필요한 곱셈 연산의 수는 행렬을 곱하는 순서에 따라 달라지게 된다.<br/>
<br/>
예를 들어, A의 크기가 5×3이고, B의 크기가 3×2, C의 크기가 2×6인 경우에 행렬의 곱 ABC를 구하는 경우를 생각해보자.<br/>
<br/>
AB를 먼저 곱하고 C를 곱하는 경우 (AB)C에 필요한 곱셈 연산의 수는 5×3×2 + 5×2×6 = 30 + 60 = 90번이다.<br/>
BC를 먼저 곱하고 A를 곱하는 경우 A(BC)에 필요한 곱셈 연산의 수는 3×2×6 + 5×3×6 = 36 + 90 = 126번이다.<br/>
같은 곱셈이지만, 곱셈을 하는 순서에 따라서 곱셈 연산의 수가 달라진다.<br/>
<br/>
행렬 N개의 크기가 주어졌을 때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구하는 프로그램을 작성하시오. 입력으로 주어진 행렬의 순서를 바꾸면 안 된다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/11049)) <br/>

## 해법
* 두 그룹을 합해야하기 때문에 2 차원 배열 `dp`를 만든다.
* 행렬을 곱할 때 `A`와 `B`를 곱 할 때를 보면 `5x3x2` 이런식으로  `M(A[1] == B[0])` 값을 합친 후 값을 구해야한다.
  * 점화식 `N×M×K` 형식으로 곱하기 위해서 행렬 크기 `N + 1` 크기의 `N, M, K` 값을 저장하는 배열을 만든다.
    * ex) `ps[0] = values[0][0], ps[1] = values[0][1]` 저장 이후 `ps[i] = values[i - 1][1]` 값을 저장해준다.
      * 위 예와 같이 저장하게 되면 `ps[i - 1] == values[i][0]` 같은 형식이 완성된다.
* `{i <= k <= j}` 형식의 반복문을 만든다.
* `k` 반복문에서 `dp[i][j]`에 값을 저장해야하는데, 저장하는 점화식은 `dp[i][k] + dp[k + 1][j] + ps[i - 1] * ps[k] * ps[j]` 와 같고 이중에서 가장 작은 값을 저장한다.
  * 점화식에서 주의해야할 점은 행렬 값 `ps`의 범위지정이 중요하다.
* 마지막으로 정답을 출력한다.

## 핵심
* `A(BC)`일 경우 `BD + A(BC)` 형식으로 답을구해야하기 때문에 2 차원 배열로 문제를 해결해야한다.
* 행렬을 곱할 때 `M` 값을 어떻게 제외시킬지 생각하는게 중요하다.