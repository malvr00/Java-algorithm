# [합분해](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step20/src/Main.java)
0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.<br/>
<br/>
덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2225)) <br/>

## 해법
* `dp[K + 1][N + 1]` 크기의 배열을 만든다.
  * 2 차원 배열로 만드는 이유는 `K` 만큼의 조합 수를 가장 낮은 경우의 수 `1` 부터 쪼개서 구하기 위해서다.
* 배열을 만들었으면 아래와 같이 배열의 원소값을 초기화한다.
  * `for(int i = 1; i <= K; i++) dp[i][0] = 1;`
    * 먼저 `0`은 조합을 아무리해도 `0`으로 밖에 구할 수 없기 때문에 `1`로 초기화한다.
  * `for(int i = 1; i <= N; i++) dp[1][i] = 1;`
    * 숫자를 하나만 사용해서 `N`을 구하는 경우는 자기 자신 밖에 없기 때문에 `1`로 초기화한다.
* 마지막으로 `K^N` 만큼 반복문을 돌면서 `dp`에 값을 쌓아나간다.
* 점화식은 다음과 같다. `dp[k - 1][n] + dp[k][n - 1]`
  * `dp[k - 1][n]`은 구해야하는 정수 `N` + `0`을 담당한다.
  * `dp[k][n - 1]`은 `dp[k][n - 1]`에서 이미 구한 조합원소 마지막 항에 `+ 1` 하는것과 같다.
    * 예를들어 `k = 2, n = 2` 일 때 `dp[k][n - 1] = {0, 1}, {1, 0}` 조합의 마지막 항에 `+ 1`을 하면 `{0, 2}, {1, 1}`가 된다.

## 핵심
* `dp` 배열의 인덱스 정의가 중요하다. 

## 문제점
* 경우의 수를 구할 때 조금 헤맸는데, `dp[k][n]` 배열의 원소에 조합의 경우의 수를 구할 때는 `이미 구한 조합 + 조합에 추가하려는 수 ({1+1,0+2} -> {1+1(+0), 0+2(+0)})` 형식으로 문제를 해결 해 왔는데 이렇게되면 정의한 `K` 인덱스 정의가 무너졌다.
* 그래서 `이미 구한 조합의 마지막 항에 + 1` 형식으로 문제를 해결했다. (새로운 접근 풀이 방법이라 괜찮은 문제같다.)