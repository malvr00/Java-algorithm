# [동물원](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step22/src/Main.java)
이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.<br/>
<br/>
동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1309)) <br/>

## 해법
* 호랑이를 우리에 가두는 방법은 `A: 호랑이를 가두지 않는다. B: 호랑이를 B 위치에 둔다. C: 호랑이를 C 위치에 둔다.` 와 같이 세 가지 방법이므로 `dp[3][N + 1]` 배열을 초기화한다.
* `N` 만큼 반복문을 돌면서 값을 쌓아나간다.
* 경우의 수에 대한 점화식은 아래와 같다.
  * `A: dp[i][0] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]`
    * `i` 위치에 호랑이를 두지 않기 때문에 `i - 1` 번 째에 어떤 상태였든지간에 모두 올 수 있기 때문에 세 가지 경우를 다 더해준다.
  * `B: dp[i][1] = dp[i - 1][0] + dp[i - 1][2]`
    * `i` 위치에 `B`에 호랑이를 둘 경우 `dp[i - 1][1]`를 제외한 경우의 수를 저장하는데 그 이유는 `dp[i - 1][1]`를 더하게 될 경우 같은위치 즉 `B` 위치에 붙어서 호랑이가 배치되기 때문에 제외한다.
  * `C: dp[i][2] = dp[i - 1][0] + dp[i - 1][1]`
    * `i` 위치에 `C`에 호랑이를 둘 경우 `dp[i - 1][2]`를 제외한 경우의 수를 저장하는데 그 이유는 `B`와 동일한 이유다.
  * 번외로 점화식을 정리하면 `2 * dp[i - 1] + dp[i - 2]`가 된다.
* 마지막으로 `dp[i][k]` 값을 모두 합 한후 정답으로 반환하면 된다.

## 핵심
* 호랑이를 우리에 가두는 가지 수를 파악한 후 해당 가지 수를 `0 ~ kth` 형식으로 조깨서 문제를 해결하면 쉽게 풀 수 있다.   

## 문제점
