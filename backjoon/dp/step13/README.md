# [팰린드롬 만들기](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step13/src/Main.java)
앞에서 뒤로 보나, 뒤에서 앞으로 보나 같은 수열을 팰린드롬 이라고 한다. 예를 들어 {1}, {1, 2, 1}, {1, 2, 2, 1}과 같은 수열은 팰린드롬 이지만, {1, 2, 3}, {1, 2, 3, 2} 등은 팰린드롬이 아니다.<br/>
<br/>
한 수열이 주어졌을 때, 이 수열에 최소 개수의 수를 끼워 넣어 팰린드롬을 만들려고 한다. 최소 몇 개의 수를 끼워 넣으면 되는지를 알아내는 프로그램을 작성하시오.<br/>

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1695)) <br/>

## 해법
* 최소 개수의 수를 끼워 넣어서 팰린드롬을 만들기 위해서는 양끝을 기준으로 `{i ~ j - 1, i + 1 ~ j}` 왼쪽 오른쪽 두 덩어리 값을 비교해서 값을 구해야하기 때문에 2 차원 배열 `dp`를 생성한다.
* `dp` 크기 만큼 반복문을 탐색하는데 기준이 되는 자기 자신은 팰린드롬 그 자체이기 때문에 `0`으로 초기화하고, 다음 `i + 1`수를 비교한다.
* 문제의 점화식 첫 번째는 양 끝 수가 같을경우 중간 범위의 수의 미리 구한 팰린드롬 값을 구해주면 된다.
  * 즉 `val[i - 1] == val[j - 1] -> dp[i][j] = dp[i + 1][j - 1] + 1`와 같다.
* 점화식 두 번째는 양 끝 수가 다를경우 `i ~ j - 1` 범위의 왼쪽 덩어리, `i + 1 ~ j` 범위의 오른쪽 덩이리 중 더 작은 수에 `+ 1` 해주면 된다.
  * 즉 `val[i - 1] != val[j - 1] -> dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1`와 같다.
* 마지막으로 `dp[1][N]` 정답을 출력한다.

## 핵심
* 팰린드롬을 쉽게 만드는 방법은 양 끝 수가 같을 때 양 끝을 제외한 범위의 팰린드롬을 구하면 된다.
  * 양 끝의 범위가 다를 경우는 각각 `i ~ j - 1` `(+ j)` 와 `(i +)` `i + 1 ~ j` 두 덩어리로 쪼개서 팰린드롬을 만들면 쉽게 답을구할 수 있다. 