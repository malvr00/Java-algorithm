# [경찰차](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step30/src/Main.java)
어떤 도시의 중심가는 N개의 동서방향 도로와 N개의 남북방향 도로로 구성되어 있다.<br/>
<br/>
모든 도로에는 도로 번호가 있으며 남북방향 도로는 왼쪽부터 1에서 시작하여 N까지 번호가 할당되어 있고 동서방향 도로는 위부터 1에서 시작하여 N까지 번호가 할당되어 있다. 또한 동서방향 도로 사이의 거리와 남 북방향 도로 사이의 거리는 모두 1이다. 동서방향 도로와 남북방향 도로가 교차하는 교차로의 위치는 두 도로의 번호의 쌍인 (동서방향 도로 번호, 남북방향 도로 번호)로 나타낸다. N이 6인 경우의 예를 들면 다음과 같다.<br/>
<br/>
이 도시에는 두 대의 경찰차가 있으며 두 차를 경찰차1과 경찰차2로 부른다. 처음에는 항상 경찰차1은 (1, 1)의 위치에 있고 경찰차2는 (N, N)의 위치에 있다. 경찰 본부에서는 처리할 사건이 있으면 그 사건이 발생된 위치를 두 대의 경찰차 중 하나에 알려 주고, 연락 받은 경찰차는 그 위치로 가장 빠른 길을 통해 이동하여 사건을 처리한다. (하나의 사건은 한 대의 경찰차가 처리한다.) 그리고 사건을 처리 한 경찰차는 경찰 본부로부터 다음 연락이 올 때까지 처리한 사건이 발생한 위치에서 기다린다. 경찰 본부에서는 사건이 발생한 순서대로 두 대의 경찰차에 맡기려고 한다. 처리해야 될 사건들은 항상 교차로에서 발생하며 경찰 본부에서는 이러한 사건들을 나누어 두 대의 경찰차에 맡기되, 두 대의 경찰차들이 이동하는 거리의 합을 최소화 하도록 사건을 맡기려고 한다.<br/>
<br/>
예를 들어 앞의 그림처럼 N=6인 경우, 처리해야 하는 사건들이 3개 있고 그 사건들이 발생된 위치 를 순서대로 (3, 5), (5, 5), (2, 3)이라고 하자. (3, 5)의 사건을 경찰차2에 맡기고 (5, 5)의 사건도 경찰차2에 맡기며, (2, 3)의 사건을 경찰차1에 맡기면 두 차가 이동한 거리의 합은 4 + 2 + 3 = 9가 되 고, 더 이상 줄일 수는 없다.<br/>
<br/>
처리해야 할 사건들이 순서대로 주어질 때, 두 대의 경찰차가 이동하는 거리의 합을 최소화 하도록 사건들을 맡기는 프로그램을 작성하시오.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2618)) <br/>

## 해법
* `문제 발생지역 = W` 길이 만큼 배열 `dp[W + 1][W + 1]`을 만든다.
  * `W + 1`로 만드는 이유는 `0`번 인덱스는 시작지점으로 사용하기 위해서이다.
  * `[a][b]` 정의는 `[a]`는 경찰 1 이 처리한 사건번호, `[b]`는 경찰 2 가 처리한 사건 번호
* 두 경찰이 탐색가능한 조합의 경우를 재귀호출을 통해 모두 탐색해본다.
* 점화식은 아래와 같다.
  * `이동거리 = abs를 통해서 경찰위치 - 사건발생위치를 해준 후 x좌표 y좌표를 합 해준다.`
  * 다음 탐색지역으로는 경찰 1은 `backtracking(idx + 1, next, b)`을 탐색한다. 경찰 2는 `backtracking(idx + 1, a, next)`를 탐색한다.
    * 경찰 1 먼저 모든 사건지역을 탐색해보고 점차 경찰 1 의 비중을 줄여간다. `W = 3, {3, 0}, {2, 1}, {1, 2} (탐색 가능한 조합의 수)`
    * 이렇게 두 경우를 탐색할 경우 중복이 탐색이 발생할 수 있는데 이 부분을 `dp[a][b] != -1 이면 이미 탐색한 지역으로 dp[a][b]를 반환한다.`

## 핵심
* 인덱스의 정의를 3 차원 배열로 처리하려다 시간초과가 발생했는데 2 차원 배열로 인덱스의 정의를 처리한 사건번호로 정의해서 시간초과를 피할 수 있었다. 

## 문제점
* 인덱스의 정의가 중요하고 `Top-down` 방식이든 `DFS` 방식이든 백트레킹을 활용해서 문제를 풀 때는 대부분은 조합을 활용한 탐색이 메인 포인트 같다.
* 조합을 구했을 때 중복이 발생하면 메모이제이션으로 중복탐색 방지하고, 중복탐색이 발생하지 않게 반복문을 통해 인덱스로 컨트롤이 된다면 메모이제이션을 사용하지 않아도 되고 결국 문제 지문을 잘 파악해서 알맞게 알고리즘을 선택해 활용해야겠다.
* 전날에 풀었던 벽장문의 이동도 결국 벽장이 이동 가능한 조합의 수 중 가장 작은 경로이동을 선택하면 됐어서 지금 문제나 벽장의 이동 문제나 결국 조합에 의한 최소 경로 찾기로 같은문제 같다.