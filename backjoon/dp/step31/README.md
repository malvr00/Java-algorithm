# [조 짜기](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step31/src/Main.java)
알고스팟 캠프에 N(1 ≤ N ≤ 1,000)명의 학생들이 참여하였다. 학생들은 열심히 공부를 하고 있었는데, 어느 날 조별 수업을 진행하기로 하였다. 조별 수업의 목적은 잘 하는 학생들과 덜 잘 하는 학생들을 같은 조로 묶어서 서로 자극을 받으며 공부하도록 만들기 위함이다. 따라서 가급적이면 실력 차이가 많이 나도록 조를 편성하는 것이 유리하다.<br/>
<br/>
하지만 조를 편성할 때 같은 조에 속하게 된 학생들의 나이 차이가 많이 날 경우에는 오히려 부정적인 효과가 나타날 수도 있다. 따라서 선생님들은 우선 학생들을 나이 순서대로 정렬한 다음에, 적당히 학생들을 나누는 방식으로 조를 짜기로 하였다. 조의 개수는 상관이 없다.<br/>
<br/>
각각의 조가 잘 짜여진 정도는 그 조에 속해있는 가장 점수가 높은 학생의 점수와 가장 점수가 낮은 학생의 점수의 차이가 된다. 또한 전체적으로 조가 잘 짜여진 정도는, 각각의 조가 잘 짜여진 정도의 합으로 나타난다. 한 명으로 조가 구성되는 경우에는 그 조의 잘 짜여진 정도가 0이 된다(가장 높은 점수와 가장 낮은 점수가 같으므로).<br/>
<br/>
학생들의 점수가 주어졌을 때, 조가 잘 짜여진 정도의 최댓값을 구하는 프로그램을 작성하시오.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2229)) <br/>

## 해법
* `N` 명의 학생 만큼 배열 `dp[N + 1]` 크기를 만든다.
  * `[i]` 정의는 `1...i` 까지 조를 나눴을 때 구할 수 있는 조의 최대값이다.
* `N^2` 반복문을 돌면서 점화식을 실행한다.
* `i`번 값을 최대, 최소 값으로 선택한다.
* `j`번 값으로 이미 구한 최대, 최소 값을 비교해서 `j` 학생과 `i` 학생 중 알맞는 최대, 최소 값을 다시 저장한다.
* `dp[i] = max(dp[i], dp[j - 1] + maxScore - minScore)`
  * `[j - 1]` 하는 이유는 `j...i` 아이들의 조를 구했으면 그 이전 구했던 `j - 1` 까지의 조 중 조 점수 최대 값을 전파하기위해 더해준다.

## 핵심
* 배열 인덱스 정의를 잘 하고, `N`이 최대 `1000`이기 때문에 2 차원 배열로도 문제 해결이 가능하다

## 문제점
