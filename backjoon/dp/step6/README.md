# [가장 긴 감소하는 부분 수열](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step6/src/Main.java)
수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오.<br/>
<br/>
예를 들어, 수열 A = {10, 30, 10, 20, 20, 10} 인 경우에 가장 긴 감소하는 부분 수열은 A = {10, 30, 10, 20, 20, 10}  이고, 길이는 3이다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/11722)) <br/>

## 해법
* `N` 길이 만큼 수열 수를 저장할 배열 `dy`를 저장한다.
* 값을 저장한 배열 `scores`를 활용해서 값이 큰 값들만 `dy`에 수를 누적합을 진행한다.
* 점화식은 `dy[i] = Math.max(dy[i], dy[j] + 1)`이다
  * `i`를 기준으로 문제에서는 작은 값을 찾지만 문제 풀이할 때는 `i`의 보다 큰 값들과 비교해서 문제를 해결한다.
    * `{10, 30, 20, 20, 10}` 일 경우 `scores[i] = 20` 이라고 했을 때 `j < i` 만큼 탐색을 진행한다.
    * `scores[i] < scores[j]` 일 경우에 점화식을 대입해서 값을 구한다. 이렇게 되면 `dy[j]`의 수열 값에 `scores[i]`를 합한 길이가 완성된다.
  * `Math.max`로 비교하는 이유는 `j` 원소가 큰 경우가 여러개 일 경우 기존에 구한 값 보다 작은 값으로 초기화될 수 있기 때문이다.
* 마지막으로 `dy` 배열 원소 중 가장 큰 값을 반화한다.

## 핵심
* 수를 비교할 기준을 잡는게 중요하다.
* `dy[i]`는 `i`까지의 수열의 수를 저장한다.

## 문제점