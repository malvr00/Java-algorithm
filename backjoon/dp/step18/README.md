# [타일 채우기](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step18/src/Main.java)
3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2133)) <br/>

## 해법
* `N + 1` 크기 만큼 배열을 만든다.
* 직관적으로 알 수 있는 `dp[0] = 1, dp[2] = 3`으로 초기화한다.
* 만약 `N`의 크기가 `홀수`라면 `0`을 반환한다.
  * `3xN`의 크기에서 `N`이 홀수라면 도형을 가득채울 수 없다.
* 점화식은 `2 가지`로 만들 수 있다.
  1. `dp[i] = dp[i - 2] * 3`
  2. 반복문을 통한 `j = i - 4; j >= 0; j -= 2` -> `dp[i] += dp[j] * 2`
* `첫 번째` 점화식 같은 경우는 직관적으로 맨 오른쪽 `2 열`을 정상적인 모양으로 마무리하면 왼쪽은 `3 x (N - 2)`가 남고, 경우의 수는 `dp[N - 2] * 3`이 된다. 
* `두 번째` 점화식은 `N`이 `4 이상` 일 경우에 튀어나온 형태`[[2,2,2,2],[1,2,2,1],[1,2,2,1]]`가 발생하는데 이 경우는 맨 오른쪽 `2 열`만을 가지고 해결할 수 없고 `4 열` 이상을 한 덩어리로 묶어서 마무리되는 모양이 존재하기에 추가 점화식이 필요하다.
  * 예를 들어 `N = 4` 일 경우에는 `[[2,2,2,2],[1,2,2,1],[1,2,2,1]` 형태로 채우는 방법이 대칭으로 존재하기 때문에 `2 = dp[N] += dp[N - 4] * 2`를 더해줘야 해줘야한다.
  * 그 다음로 만약 `N = 6` 일 경우에는 맨 오른쪽 `2 열`을 한 덩어리로 채우는 방식뿐만 아니라 오른쪽 `4 열`을 한 덩어리로 채우는 방식도 발생한다. 그래서 맨 왼쪽의 `3x2` 타일 경우의 수를 더해주는 `dp[N] += dp[N - 4] * 2`를 추가로 더해주고, 마지막으로 `N = 4`일 때의 경우와 같이 튀어나온 형태의 타일이 새롭게 생겨 `dp[N] += dp[N - 6] * 2` 해준다.

## 핵심
* `N`이 홀수 일 경우 타일을 채울 수 없다는 점을 파악해야한다.
* 튀어나온 모양의 특수타일이 발생한다는 점과, `첫 번째` 점화식은 맨 오른쪽 `2 열`을 먼저구하는 점화식으로 `N = 6` 이상 넘어 갈 경우 맨 왼쪽 기준으로도 타일을 채우는 경우의 수를 구해줘야한다. 

## 문제점
* 튀어나온 타일을 생각못했다.