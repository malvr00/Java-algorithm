# [스티커](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step14/src/Main.java)
상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.<br/>
<br/>
상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.<br/>
모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.<br/>
<br/>
위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/9465)) <br/>

## 해법
* DP로 문제를 해결해야하기 때문에 배열 `dp`를 생성한다.
  * `[3][K]` 형식으로 배열을 생성해야하는데 행이 3 인 이유는 `kth` 값을 선택할 때 `{위 스티커 선택, 아래 스티커 선택, 스티커 선택 안함}`의 경우의 수가 있기 때문에 행을 3 으로 만들어준다.
* 탐색을 하기 전에 맨 처음 스티커는 스티커 배열 `board`의 0 번째 행 값을 넣어준다.
  * `[0][0] (윗 스티커) = board[0][0], [1][0] (아래 스티커) = board[1][0], [2][0] (선택안함) = 0`
* 이제 탐색을 진행하면서 최적의 스티커를 선택한다. 점화식은 아래와 같다.
  * `dp[0][i] = max(dp[1][i - 1], dp[2][i - 1]) + board[0][i]`           위 선택
  * `dp[1][i] = max(dp[0][i - 1], dp[2][i - 1]) + board[1][i]`           아래 선택
  * `dp[2][i] = max(dp[2][i - 1], Math.max(dp[0][i - 1], dp[1][i - 1]))` 선택안함
* 탐색을 모두 완료했다면, `{위, 아래, 선택안함}` 값 중 가장 큰 값을 반환한다.

## 핵심
* 점화식을 세우는게 중요하고, 문제를 잘 읽어보면 스티커를 위에 선택한 경우, 아래를 선택한 경우, 선택하지 않은 경우 이렇게 3 가지 예시가 주어지기 때문에 이 점을 잘 생각해서 배열을 생성하고 문제를 해결하면 된다.