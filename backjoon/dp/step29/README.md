# [벽장문의 이동](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step29/src/Main.java)
n개의 같은 크기의 벽장들이 일렬로 붙어져 있고 벽장의 문은 n-2개만이 있다. 한 벽장 앞에 있는 문은 이웃 벽장 앞에 문이 없다면(즉, 벽장이 열려있다면) 그 벽장 앞으로 움직일 수 있다.<br/>
<br/>
그림은 7개의 벽장의 예이다. 그림에서 2번 벽장과 5번 벽장이 열려있고, 나머지 벽장은 닫혀 있다.  벽장 문은 좌우 어느 쪽이든 그 이웃 벽장이 열려 있다면 그 쪽으로 한 칸씩 이동할 수 있다. 그림에서 주어진 상태에서는 1번 벽장을 닫고 있는 벽장문을 오른쪽으로 한 칸 이동함으로써 1번 벽장을 사용할 수 있다. 이때 2번 벽장은 닫혀져 사용할 수 없다. 역시 5번 벽장이 열려 있으므로 4번 벽장 또는 6번 벽장 앞의 벽장문을 5번 벽장 앞으로 이동시킬 수 있다.<br/>

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2666)) <br/>

## 해법
* `DP Top-down`방식으로 점화식을 간단하게 할 수 있는데 먼저 `dp[사용할 벽장들의 순서 길이][열려있는 벽장 1][열려있는 벽장 2]`로 배열을 만든다.
  * 배열을 만든 후 배열의 원소 값을 방문을 안했을 경우의 상태를 만들기 위해서 `-1`로 초기화한다.
* 재귀호출할 함수를 만들고 점화식을 실행한다.
  1. `dp[벽장 순서][열려있는 벽장 1][열려있는 벽장 2]`의 위치에 `-1`이 아닌 값이 있으면 그 값을 반환한다.
     * `-1`이 아닌경우는 재귀호출로 방문하여 벽장 이동한 최소 값이 저장되어 있다.
  2. `열려있는 벽장`들의 값은 정렬해서 사용하여 중복 방문의 수를 줄인다.
  3. 마지막으로 `dp[idx][tempA][tempB] = min(|val - tempA| + 재귀호출(idx + 1, val, tmepB), |val - tempB| + 재귀호출(idx + 1, tempA, val))`로 배열에 값을 쌓아서 결과 값을 반환한다.

## 핵심
* `Top-dwon` 방식을 활용하면 점화식이 좀 더 간단하게 진행된다.

## 문제점
* `Bottom-up` 방식만 주로 사용했는데 `Top-down` 방식도 백트레킹 연습할 겸 많이 풀어봐야겠다. 그리고 `Top-down` 방식을 채택했을 때 어떤 문제들은 좀 더 단순하게 점화식을 접근할 수 있어서 좋은것 같다.