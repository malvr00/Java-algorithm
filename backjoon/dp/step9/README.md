# [내리막 길](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dp/step8/src/Main.java)
여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다. <br/>
현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.<br/>
지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1520)) <br/>

## 해법
* 먼저 `{N, M}`만큼 재귀탐색을 진행해야한다.
* 방문했던 정보를 저장할 `dy`배열 크기를 `[N][M]`만큼 크기를 초기화한다.
* 그리고 모든 `dy`의 원소 값을 `-1`로 초기화한다.
  * 방문한 값을 `0`으로 하기 위함이다. 초기 값을 `0`으로 지정하고 방문확인할 때 에러사항이 발생한다.
* 이제 재귀호출을 진행하면서 먼저 현재 위치가 목표 좌표에 도착할 경우 `1`을 반환한다.
* 그 다음 `dy[현재위치][현재위치]`의 값이 `-1`이 아니면 이미 방문한 위치이기 때문에 `dy[현재위치][현재위치]`를 반환한다.
* 위 두 조건을 모두 통과하고 새로운 위치에 도착했다면 현재 위치를 `0`으로 초기화(방문했다는 흔적)하고 상하좌우 다음 위치를 탐색한다.
  * 이때 탐색하면서 반환되는 값은 `dy[현재위치][현재위치]`에 누적합 방식으로 더해준다.
* 마지막으로 모든 재귀가 끝나면 `dy[0][0]` 위치에 저장된 마지막 경로까지 도착한 경로를 반환한다.

## 핵심
* `DP`의 `Top-Down` 방식을 활용해서 문제를 풀어야 시간초과 없이 문제를 해결할 수 있다.
