# [로봇](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dfs_bfs/step20/src/Main.java)
많은 공장에서 로봇이 이용되고 있다. 우리 월드 공장의 로봇은 바라보는 방향으로 궤도를 따라 움직이며, 움직이는 방향은 동, 서, 남, 북 가운데 하나이다. 로봇의 이동을 제어하는 명령어는 다음과 같이 두 가지이다.

명령 1. Go k: k는 1, 2 또는 3일 수 있다. 현재 향하고 있는 방향으로 k칸 만큼 움직인다.
명령 2. Turn dir: dir은 left 또는 right 이며, 각각 왼쪽 또는 오른쪽으로 90° 회전한다.
공장 내 궤도가 설치되어 있는 상태가 아래와 같이 0과 1로 이루어진 직사각형 모양으로 로봇에게 입력된다. 0은 궤도가 깔려 있어 로봇이 갈 수 있는 지점이고, 1은 궤도가 없어 로봇이 갈 수 없는 지점이다. 로봇이 (4, 2) 지점에서 남쪽을 향하고 있을 때,  이 로봇을 (2, 4) 지점에서 동쪽으로 향하도록 이동시키는 것은 아래와 같이 9번의 명령으로 가능하다.



로봇의 현재 위치와 바라보는 방향이 주어졌을 때, 로봇을 원하는 위치로 이동시키고, 원하는 방향으로 바라보도록 하는데 최소 몇 번의 명령이 필요한지 구하는 프로그램을 작성하시오.<br/>

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1726)) <br/>

## 해법
* 먼저 입력에서 주어지는 방향으로는 90도 회전을 구하기가 어렵기 때문에 90도 회전하기 수월하게 움직이는 값 바꾼 후 `BFS` 탐색을 진행한다.
* 방문 체크 배열을 만들고, 시작 위치 값을 `Queue`에 담고 시작위치를 체크배열에 `0`으로 초기화한다.
  * 체크 배열은 `3 차원`으로 만들어야하고 해당 원소들은 `-1`로 초기화한다.
* `BFS` 탐색을 시작하면서 가장 먼저 도착지점에 도착했나 확인하고 도착했으면 정답을 반환한다.
* 도착지점에 도착하지 못했다면 문제에서 왼쪽 또는 오른쪽으로 90도 이동한다고 했으니 현재 방향에서 왼쪽 또는 오른쪽으로 이동한 위치 값의 좌표에 처음으로 도착했다면 `['현재 x']['현재 y']['현재 방향'] + 1` 해준다.
* 최대 `k = 3`번 움직일 수 있으니 `k`를 기준으로 `{nX, nY}` 값을 구해준다.
  * 점화식은 `nX = cur.x + X[cur.dir] * k, nY = cur.y + Y[cur.dir] * k` 이다.
* 다음 위치가 벽에 가로박히면 탐색을 종료하고, 다음 위치가 `N*M` 범위를 벗어나지 않고 처음방문한 위치라면 `['현재 x']['현재 y']['현재 방향'] + 1` 해준다.
* 도착지점에 도착할 수 없으면 `0`을 반환한다.

## 핵심
* 90도 회전을 하기 편하게 초기 위치값을 변경해서 문제를 풀면 쉽게 풀 수 있다.
* 다음 위치를 탐색할 때 `board[nX][nY][cur.dir]` 원소가 `1`이면 `continue` 하지않고 `break`로 탐색을 바로 종료해야한다. 바로 종료하지 않으면 벽을 뛰어넘고 탐색이 진행 될 수 있어서 조심해야한다.