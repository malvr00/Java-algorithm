# [토마토](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dfs_bfs/step6/src/Main.java)
철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.<br/>
<br/>
창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.<br/>
<br/>
토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/7569)) <br/>

## 해법
* 3 차원으로 생각해야하는 문제이기 때문에 `Z, X, Y` 축으로 이동하는 배열을 각각 만든 후 토마토가 보관되어 있는 배열 `board`의 원소들 중 `1`인 값을 `Queue`에 넣는다.
  * `BFS`돌리기 전 `Queue`에 값이 하나도 없다면 토마토 전파가 불가능하기 때문에 `-1`을 반환한다.
* 탐색을 조건을 모두 충족하면 `Queue`에 방금 익은 토마토 좌표를 저장하고 해당 좌표에 `(기준이 되는 토마토 좌표 원소 값) + 1`을 저장한다.
  * 탐색조건은 아래와 같다.
    * `board` 범위를 벗아나지 않는 조건.
    * 토마토 익히려고하는 좌표에 원소 값이 `0`인 좌표.
* 마지막으로 `board`를 탐색하면서 `0`이 존재하면 `-1` 반환하고, 모두 익었다면 `board` 원소 값 중 가장 큰 값을 저장한 후 정답으로 반환한다.

## 핵심
* 3 차원 배열로 문제를 풀어야해서 어려워 보이지만 `{위, 아래}`를 어떻게 움직일지만 생각하면 쉽게 풀 수 있다. 

## 참고
