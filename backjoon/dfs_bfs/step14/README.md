# [퍼즐](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dfs_bfs/step14/src/Main.java)
3×3 표에 다음과 같이 수가 채워져 있다. 오른쪽 아래 가장 끝 칸은 비어 있는 칸이다.
```
1	2	3
4	5	6
7	8
```
	 
어떤 수와 인접해 있는 네 개의 칸 중에 하나가 비어 있으면, 수를 그 칸으로 이동시킬 수가 있다. 물론 표 바깥으로 나가는 경우는 불가능하다. 우리의 목표는 초기 상태가 주어졌을 때, 최소의 이동으로 위와 같은 정리된 상태를 만드는 것이다. 다음의 예를 보자.

```
1	 	3
4	2	5
7	8	6
```

```
1	2	3
4	 	5
7	8	6
```

```
1	2	3
4	5	 
7	8	6
```

```
1	2	3
4	5	6
7	8	 
```

가장 윗 상태에서 세 번의 이동을 통해 정리된 상태를 만들 수 있다. 이와 같이 최소 이동 횟수를 구하는 프로그램을 작성하시오.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1525)) <br/>

## 해법
* 빠르게 탐색을 완료해야 하기 때문에 `BFS` 탐색을 진행한다.
* 퍼즐을 맞추기 위해서는 순서대로 `{1, 2, 3}, {4, 5, 6}, {7, 8 ,0}` 존재해야하며, 탐색전에 이미 완성된 퍼즐인지를 확인한다.
  * 매번 반복문을 통해서 퍼즐을 확인하기에는 비효율 적이므로 `123456780` 형태의 `String`으로 퍼즐을 확인한다.
* 퍼즐의 범위를 벗어나지 않았다면 해당 LEVEL의 퍼즐을 현재 위치와 다음 위치의 원소 값을 교환해준다.
* 교환이 완료된 후 퍼즐을 `String`으로 변환한 후 방문한적이 있는지 확인하고 최초방문이라면 `Queue`에 다음 탐색할 노드로 저장한다.
* 끝 까지 퍼즐을 완성하지 못한다면 `-1`을 반환한다.

## 핵심
* 퍼즐 완성비교를 매번 반복문을 통해서 확인하는건 비효율적이다.
  * `String`으로 변환하여 수열을 만든 후 완성된 퍼즐인지 비교하면 효율적으로 정답을 찾을 수 있다.
* 노드를 탐색할 때 기준이 되는 퍼즐의 원소 값이 변경 돼서 기준이되는 퍼즐이 상태가 변화했기 때문에 새로운 상태 즉 변경된 퍼즐을 새롭게 만든 후 탐색을 계속 진행해야한다.
  * 여기서 주의해야 할 점은 2 차원 배열은 주소 값을 공유하기 때문에 `깊은복사`를 진행해야한다.