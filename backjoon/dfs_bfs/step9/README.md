# [빙산](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dfs_bfs/step9/src/Main.java)
지구 온난화로 인하여 북극의 빙산이 녹고 있다. 빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자. 빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다. 빙산 이외의 바다에 해당되는 칸에는 0이 저장된다. 그림 1에서 빈칸은 모두 0으로 채워져 있다고 생각한다.<br/>
<br/>
```
 	2	4	5	3	 	 
 	3	 	2	5	2	 
 	7	6	2	4	 	 
```
그림 1<br/>
<br/>
그림 1. 행의 개수가 5이고 열의 개수가 7인 2차원 배열에 저장된 빙산의 높이 정보<br/>
<br/>
빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에, 배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다. 단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. 바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다. 따라서 그림 1의 빙산은 일년후에 그림 2와 같이 변형된다.<br/>
<br/>
그림 3은 그림 1의 빙산이 2년 후에 변한 모습을 보여준다. 2차원 배열에서 동서남북 방향으로 붙어있는 칸들은 서로 연결되어 있다고 말한다. 따라서 그림 2의 빙산은 한 덩어리이지만, 그림 3의 빙산은 세 덩어리로 분리되어 있다.<br/>
<br/>

```
    2	4	1	 	 
 	1	 	1	5	 	 
 	5	4	1	2
```
그림 2<br/>

```
 	 	 	3	 	 	 
 	 	 	 	4	 	 
 	3	2	 	 	 	 
```
그림 3<br/>
<br/>
한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오. 그림 1의 빙산에 대해서는 2가 답이다. 만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/2573)) <br/>

## 해법
* `DFS` 탐색을 진행하면서 원소가 `0`이 아닌 영역이 몇 개 인지 카운트한다.
  * 영역이 `2 이상`을 발견할 경우 문제에서 구해달라는 최소의 시간을 찾았기 때문에 해당 시간을 반환한다.
  * 영역이 `0`일 경우 더 이상 얼음이 존재하지 않기 때문에 탐색을 종료한다.
* 탐색이 완료되면 얼음을 녹여야하는데 반복문을 통해서 녹여야하는 해당 좌표에서 `4 방향` 중 `0`이 몇 개 인지 카운트 한 후 카운트 개수 만큼 해당 좌표의 얼음을 녹인다.
  * 얼음을 녹일 때 얼음을 녹이기 전 이전 상태 값을 저장하고 있는 `board`를 기준으로 얼음을 녹여야한다. 이렇게 하지 않을 경우 `2`만 녹여야하는데 `3`이 녹여진다던지 문제가 발생한다. 
  * 얼음을 녹일 때 `0` 보다 작을 경우 편의상 `0`으로 초기화한다. (문제에서도 음수일 경우 `0`으로 유지시키라고 제시했다.)
* 얼음 녹이기가 완료되면 녹이기 기준이 되는 `board`를 녹인 얼음 `board`로 스냅샷한다.

## 핵심
* `whlie` 문으로 문제를 해결하는데, 얼음 원소 값 중 가장 큰 값으로 반복문을 시작할 경우 정답을 구할 수 없다.
  * 얼음이 `1` 씩 녹는게 아니고 녹일 얼음을 기준으로 `4 방향`의 `0`의 수로 최소 `1` 이상 얼음이 녹기 때문에 원하는 결과 값을 얻을 수 없다. 

## 참고
