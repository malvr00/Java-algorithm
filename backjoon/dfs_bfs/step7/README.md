# [숨바꼭질](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dfs_bfs/step7/src/Main.java)
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.<br/>
<br/>
수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1697)) <br/>

## 해법
* 중복 탐색을 막기위해 메모이제이션을 활용해야하기 때문에 방문확인용 배열 `board`, 최단 시간에 동생의 위치를 바로 찾아서 탐색을 종료해야 하기 때문에 `BFS` 탐색을 진행한다.
  * `board`는 문제에서 주어지는 최대길이 `100,000`의 배열을 생성한다.
    * `100,000` 크기의 배열을 만드는 이유는 만약에 `N, K` 정수 중 가장 큰 수로 배열을 만들 경우 배열의 크기를 넘는 경로로 탐색해야 최소경로가 되는 경우도 있는데 이 경우를 탐색할 수 없기 때문에 문제에서 주워지는 최대 값으로 배열을 만든다.
* 탐색할 때 최소 값 들만 저장해야 하기 때문에 `board`의 원소는 `Integer.MAX_VALUE`로 초기화 한 후 수빈이 위치 `N`은 `0`으로 초기화한다.
* `BFS` 탐색을 진행하는데 조건은 아래와 같다.
  * `board` 범위를 벗어나지 않아야한다.
  * `board[next] > board[now + 1]` 즉 현재 위치에서 다음 위치로 이동할 때 그 이동 값이 최소 값 일 때만 이동한다.
* 탐색했을 때 끝 까지 동생을 찾이 못한다면 `0`을 반환한다.

## 핵심
* 중복탐색을 막아야하는데, 방문했던 위치의 이동 값은 항상 최소 값이 저장되어야한다.

## 참고
