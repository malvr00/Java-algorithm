# [연결 요소의 개수](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dfs_bfs/step12/src/Main.java)
철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.



창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.

토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.

([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/7576)) <br/>

## 해법
* 토마토들이 동시에 자신을 기준으로 네 방향에 인접한 토마토가 있을 때 토마토를 익게 만들어야하기 때문에 `BFS`를 선택해서 탐색을 진행한다.
  * 탐색 이전에 상자에 토마토가 있는 좌표값들은 모두 `Queue`에 저장한다.
* 탐색을 진행하면서 이제 안익은 토마토들을 찾아가며 익게 만들면 된다. 그리고 탐색의 조건은 아래와 같다.
  1. 주어지는 상자크기의 범위를 벗어나면 안된다.
  2. 토마토가 들어있지 않거나 이미 익은 토마토 일 경우 해당 탐색을 종료한다.
  3. 익지 않은 토마토일 경우 `board[nX][nY] = board[x][y] + 1`로 해당 위치에 토마토가 익은 날짜를 저장한다.
* 마지막으로 상자를 탐색하면서 모두 익은 토마토가 있을 경우 날짜 중 가장 큰 값을 반환하고, 익지 않은 토마토`(0)`가 존재할 경우 `-1`을 반환한다.
  * 가장 큰 값을 반환하는 이유는 `BFS` 탐색을 진행했기 때문에 배열 원소의 값 중 가장 큰 값이 최소 날짜가 된다.

## 핵심
* `BFS`탐색을 진행하면서 `LEVEL` 별 탐색을 진행할 때 중복 탐색을 어떻게 막을지가 중요하다. 주어지는 `N*M`의 크기를 생각하지 않고 막을 경우 시간초과가 발생할 수 있다.

## 참고
