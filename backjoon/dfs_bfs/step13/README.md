# [말이 되고픈 원숭이](https://github.com/malvr00/Java-algorithm/blob/master/backjoon/dfs_bfs/step13/src/Main.java)
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 녀석은 말(Horse)이 되기를 간절히 원했다. 그래서 그는 말의 움직임을 유심히 살펴보고 그대로 따라 하기로 하였다. 말은 말이다. 말은 격자판에서 체스의 나이트와 같은 이동방식을 가진다. 다음 그림에 말의 이동방법이 나타나있다. x표시한 곳으로 말이 갈 수 있다는 뜻이다. 참고로 말은 장애물을 뛰어넘을 수 있다.
```
 	x	 	x	 
x	 	 	 	x
        말	 	 
x	 	 	 	x
    x	 	x
```
근데 원숭이는 한 가지 착각하고 있는 것이 있다. 말은 저렇게 움직일 수 있지만 원숭이는 능력이 부족해서 총 K번만 위와 같이 움직일 수 있고, 그 외에는 그냥 인접한 칸으로만 움직일 수 있다. 대각선 방향은 인접한 칸에 포함되지 않는다.

이제 원숭이는 머나먼 여행길을 떠난다. 격자판의 맨 왼쪽 위에서 시작해서 맨 오른쪽 아래까지 가야한다. 인접한 네 방향으로 한 번 움직이는 것, 말의 움직임으로 한 번 움직이는 것, 모두 한 번의 동작으로 친다. 격자판이 주어졌을 때, 원숭이가 최소한의 동작으로 시작지점에서 도착지점까지 갈 수 있는 방법을 알아내는 프로그램을 작성하시오.
([자세한 문제는 백준 참고](https://www.acmicpc.net/problem/1600)) <br/>

## 해법
* 최소이동 개수를 찾아야하기 때문에 `BFS` 탐색을 진행한다.
* 탐색 전 중복 탐색을 방지하기 위해서 `visited[N][M][K + 1]` 크기의 배열을 만든다.
  * 3 차원 배열로 만드는 이유는 도착지점에 이동했을 때 특수이동이 몇 개가 남아있냐에 따라 이동 개수가 달라지므로 좌표 별 상태값도 가지고 있어야한다.
* 탐색을 진행하면서 맨 처음 원숭이를 특수이동 개수 `K`를 모두 소진하지 않았다면 특수이동을 진행한다.
  * 격자판의 범위를 벗어나지 않고, 이동하려는 다음 위치에 벽이 없어야한다.
  * 이동하려는 위치는 최초 방문이여야한다. `(visited[next_x][next_y][used] == -1)`
    * 최초 방문만 확인하는 이유는 `BFS` 특성상 `{x, y}` 위치에 최초로 도착하면 그 값이 최소 값이기 때문이다.
* 마지막으로 현재 위치가 도착지점이라면 이동 수를 반환한다.
  * 끝 까지 마지막 지점까지 이동하지 못 했다면 `-1`을 반환한다.

## 핵심
* 중복방문 방지를 위해 3 차원 배열을 활용해서 문제를 해결해야한다.
  * `BFS`는 “한 상태를 처음 방문한 게 최단거리”라는 성질을 이용하기 때문에 이동하는 상태 값이 사용한 `K` 에 따라 달라지기 때문에 3 차원 배열로 원숭이가 움직였을 때에 상태값도 따로 저장해줘여한다.
