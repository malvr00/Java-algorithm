# [* 멀티태스킹](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap4/stap4-6/src/Main.java)
현수의 컴퓨터는 멀티태스킹이 가능하다. 처리해야 할 작업이 N개 들어오면 현수의 컴퓨터는 작업을 1부터 N까지의 번호를 부여하고 처리를 다음과 같이 한다.<br/>
1) 컴퓨터는 1번 작업부터 순서대로 1초씩 작업처리를 한다. 즉 각 작업을 1초만 처리하고 다 음 작업을 하는 식이다.<br/>
2) 마지막 번호의 작업을 1초 했으면 다시 1번 작업으로 가서 다시 1초씩 후속 처리를 한다.<br/> 
3) 처리가 끝난 작업은 작업 스케쥴에서 사라지고 새로운 작업은 들어오지 않는다.
   그런데 현수의 컴퓨터가 일을 시작한 지 K초 후에 정전이 되어 컴퓨터가 일시적으로 멈추었 다. 전기가 들어오고 나서 현수의 컴퓨터가 몇 번 작업부터 다시 시작해야 하는지 알아내야 합니다.
<br/>

## 내가 푼 방식
- 작업해야 하는 값을 큐에 저장해 정전시간 k 만큼 흘렀을 때 큐의 맨 앞의 값을 인덱스를 출력했다.
<br/>

## 강의
- 먼저 작업이 끝나는 값을 찾아야 하기 때문에 새로운 배열에 복사한다. 그리고 주이진 작업 총 개수를 rest에 저장한다.
  - 이때 복사하는 값은 n + 1의 값으로 복사한다. 그 이유는 정전시간 k 시간이 주워졌을 때 작업이 종료 되면 k 시간을 작업이 끝나느 시간 만큼 빼서 정전시간을 초기화할 거기 때문이다
  - ex) time = (array[i] - array[i - 1]) * rest 을 계산할 경우 i 번째의 작업 종료시간을 알 수 있다. 즉 작업 종료시간이 정전 시간인 k 보다 작을 경우 정전이 되기 전에 작업이 끝나기 때문에 작업이 종료되는 시간만큼 k 값에서 제외시킨다.
- 작업 종료시간 time이 정전시간인 k 값보다 클 경우 정전이 된 후 다시 전기가 들어왔을 때 재 작업 확률이 있기때문에 정답을 찾는다.
- 정답을 찾을 때 이전에 정전시간 보다 종료시간이 더 작은 값들을 제외 시켰기 때문에 작업 배열에서 array[i] 값 보다 작은 값들은 이미 작업이 종료된 값 이기에 if 문으로 거른다.
- 작은 값들을 제외하고, 정전이 된 후 다시 작업이 시작 됐을 때 다시 작업을 수행하는 값을 찾는다.
  - 여기서 정전시간 k 번 만큼 반복하면 문제에서 k는 최대 2 x 10^13 이기 때문에 k(정전 시간) % rest(남은 작업 개수)와 같은 방법으로 반복문을 전부 돌지않고 반복해야 하는 최소 값을 찾아 정답을 찾는다.

<br/>

## 문제점
- 내가 푼 방식은 k 가 10^13일경우 너무 많은 값의 반복을 돌아야하기 때문에 시간초과가 발생한다. 
  - 값을 회전하는 문제는 규칙을 잘 파악 후 문제를 해결해 나가야 한다.
