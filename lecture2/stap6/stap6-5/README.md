# [IP 주소](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap6/stap6-5/src/Main.java)
매개변수 s에 숫자로 구성된 문자열이 주어지면 이 문자열을 이용하여 유효한 IP주소의 경우 들을 찾고 싶습니다.<br/>
만약 문자열 s = "2025505" 이 주어지면 만들 수 있는 유효한 IP 주소는 ["20.25.50.5","20.255.0.5","202.5.50.5","202.55.0.5"] 와 같습니다.<br/>
위에 입력의 경우 "2.0.255.0.5"와 같이 5개로 구성되어 있거나, "2.025.50.5"와 같이 0으로 시작하거나, "20.2.5.505"와 같이 255보다 큰 숫자가 존재하거나 하면 안됩니다.<br/>
1) IP 주소는 4개의 숫자가 . 로 구분되어 있습니다.<br/>
2) IP 주소의 4개의 숫자는 0 ~ 255사이의 숫자로 구성됩니다.(0, 255포함)<br/>
3) IP 주소의 4개의 숫자는 0으로 시작하는 2자리 이상의 숫자는 안됩니다.<br/>
<br/>

## 내가 푼 방식
- 먼저 IP 누적되는 값을 차례로 저장하는 배열 memo[]를 만든다.
- DFS 탐색을 할 때 숫자 자릿 수를 기준으로 최대 값 4 까지 탐색을 진행한다.
- 해당 깊이(lv) memo[lv] 값을 StringBuilder에 저장 후 문자열 s 값 하나를 append 한다
  - 이때 첫 째 자리 값이 '0' 일 경우 memo[lv]을 빈 값으로 초기화 하고 해당 노드를 제거한다.
  - StringBuilder 값이 255를 초과할 경우 memo[lv]을 빈 값으로 초기화 하고 해당 노드를 제거한다.
- 최대 깊이까지 도달하고, 문자열을 끝 까지 탐색했을 때 memo에 저장되있는 값을 배열에 '.' 를 추가해서 저장한다.
<br/>

## 강의
- IP 누적되는 값 저장할 LinkedList와 정답을 저장할 ArrayList를 만든다.
- DPS 탐색을 하면서, 문자열 탐색 값 `start`의 값이 반복문 `i` 보다 작을경우와 해당 문자의(s.charAt(start)) 값이 '0' 일 경우 해당 노드를 제거한다.
- s.substring(start, i + 1) 만 큼의 문자가 255 초과하지 않을경우 LinkedList에 저장한다.
- 최대 깊이까지 도달하고, 문자열을 끝 까지 탐색했을 때 memo에 저장되있는 값을 배열에 '.' 를 추가해서 저장한다.
<br/>

## 문제점
- 깊이를 4로 설정하고 탐색을 진행 할 때 쓸때 없는 탐색이 많아진다. 예를 들면 `'2'.'0'.'2'.'2'` 값이 도달했을 때 문자열을 끝 까지 탐색하지 않았기 때문에 정답으로 도출할 수 없다. 그래서 문제를 풀 때 문자열 탐색을 끝 까지 했는지 확인하는 코드를 추가 했는데, 이 부분이 비효율적인 것 같다.
  - 깊이를 3 으로 설정하고, 현재까지 탐색한 값 `i` 이후의 값 들을 합한 후 '0'과, '255'를 초과하는지 검증하는 로직을 추가하면, 불필요한 탐색을 많이 줄일 수 있을 것 같다. 