# [알파코드](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap6/stap6-6/src/Main.java)
철수와 영희는 서로의 비밀편지를 암호화해서 서로 주고받기로 했습니다.<br/>
그래서 서로 어떻게 암호화를 할 것인지 의논을 하고 있습니다.<br/>
영희 : 우리 알파벳 A에는 1로, B에는 2로 이렇게 해서 Z에는 26을 할당하여 번호로 보내기 로 하자.<br/>
철수 : 정말 바보같은 생각이군!! 생각해 봐!! 만약 내가 “BEAN"을 너에게 보낸다면 그것을 암호화하면 25114이잖아!! 그러면 이것을 다시 알파벳으로 복원할 때는 많은 방법이 존재하는 데 어떻게 할건데... 이것을 알파벳으로 바꾸면 BEAAD, YAAD, YAN, YKD 그리고 BEKD로 BEAN말고도 5가지나 더 있군.<br/>
당신은 위와 같은 영희의 방법으로 암호화된 코드가 주어지면 그것을 알파벳으로 복원하는데 얼마나 많은 방법이 있는지 알고싶습니다.
<br/>

## 내가 푼 방식
- DFS 탐색을 진행하면서 암호화된 코드를 찾아 볼 때 '문자열 시작 인덱스'를 parameter로 값을 받아 문자열.substring('문자열 시작 인덱스', '문자열 시작 인덱스' + 1) 만큼 재귀호출 하기 전에 먼저 암호화될 수 있는지 확인한다.
  - `'0' == 문자 || 26 < 문자` 일 경우 노드르 제거한다.
- 마지막 문자열 까지 탐색에 성공했다면, 카운트를 1 증가한다.
<br/>

## 강의
- DFS 탐색을 진행 할 때 메모이제이션 방법을 선택해 탐색 범위를 줄이는 방법을 택한다.
- 암호문자를 만들 때 최대 2 자리까지만 가능하기 때문에 자식노드를 2 개씩 생성해 나간다.
  - 왼쪽 노드 - DFS('문자열 시작 인덱스' + 1), 오른쪽 노드 - DFS('문자열 시작 인덱스' + 2) --> 오른쪽 노드는 값이 26 초과하는지 확인하는 검증이 추가로 필요하다
- 노드 탐색 도중 문자열 끝에 다다를경우 1을 리턴한다. 만약 문자열 탐색도중 문자열 탐색했을 때 그 숫자가 0 일 경우 0을 리턴한다.
- 마지막으로 메모이제이션에 값을 저장해야하는데, 왼쪽노드 반환하는 값 + 오른쪽노드 반환하는 값을 메모이제이션['현재 탐색한 노드 깊이']에 값을 저장한다.
- 암호문자를 계속 탐색할 때 만약 메모이제이션의 값이 0 이 아닐경우 이미 탐색한 값이기 때문에 메모이제이션의 해당 노드 값을 리턴한다.
  - 이렇게 메모이제이션을 사용하면 중복 탐색을 방지할 수 있다.
<br/>

## 차이점
- 내가 푼 방식은 문자열 탐색을 진행하면서 탐색할 문자열을 0 인지, 26을 초과하는지 검증 후 값이 해당 할 경우 해당 노드를 제거하는 방식을 택했다.
- 강의에서는 문자열을 최대 2 자리까지 쪼개가면서 해당 문자열에 알파벳이 존재하는 경우의 수를 저장해 그 값을 리턴하도록 했다.
  - 자식노드를 2 개만 생성해서 가는 이유는 26 이하의 숫자만 가능하기 때문에 자식노드를 2 개만 생성해서 탐색한다.
  - 내가 푼 방식처럼 전체를 모두 탐색하지 않고, 문자열을 둘로 쪼개가면서, 알파벳이 존재하는 경우의 수만 찾더라도 정답이 나온다.
    - 예를들어 '25111' 값이 주어질 때 '25111'의 값이 알파벳을 만들 수 있는 경우의 수만 카운트 한다면 알파벳을 만들 수 있는 전체 경우의 수가 나온다.
