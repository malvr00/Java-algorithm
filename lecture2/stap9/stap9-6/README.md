# [수확](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap9/stap9-6/src/Main.java) [ 백준 골드 3 ]
1 × N 크기의 긴 밭에 벼가 심어져 있다. 준희는 이 벼를 수확 하려고 한다. 그런데 가운데 있는 벼를 수확을 하려면 끝에서 가운데까지 헤집고 들어가야 하므로 양 끝에 있는 벼만 수확을 할 수 있다. 처음에는 첫 번째와 N번째 벼를 수확을 할 수 있을 것이며 만약에 첫 번째 벼를 수확을 하였다면 두 번째 벼와 N번째 벼를 수확을 할 수 있다.<br/>
수확을 하였을 때 얻을 수 있는 이익은 다음과 같다. 만약에 그 벼의 가치가 v(i)라고 하고 그 벼를 k번째로 수확을 한다고 하면 v(i) × k 만큼의 이익을 얻게 된다.<br/>
만약에 벼의 가치가 차례로 1 3 1 5 2 라고 하고 첫 번째, 다섯 번째, 두 번째, 세 번째, 네 번째의 순서대로 수확을 한다고 하면 1×1 + 2×2 + 3×3 + 4×1 + 5×5 = 43 이 되어 43 만큼의 이익을 얻게 된다. 그리고 이 값이 저 벼로 얻을 수 있는 최대 이익이 된다.<br/>
우리가 구해야 할 값은 다음과 같다. 벼의 개수 N과 벼의 가치가 주어져 있을 때, 얻을 수 있는 최대 이익을 구하는 프로그램을 작성하시오.<br/>
<br/>

## 푼 방식
- 주어지는 `N`개의 값을 가지고 최대 이익을 구해야하는데, 1 차원 배열로는 값을 구하기 어렵기 때문에 2 차원 배열로 차근차근 문제를 해결한다.
- 최초 인덱스들의 시작의 값의 길이는 한 자리이기 때문에 2 차원 배열의 해당 인덱스 번호의 값을 `nums[N]`으로 초기화한다.
  - `dy[N+1][N+1]`의 2 차원 배열에 `nums[i]`의 값들을 `dy[i][i] = nums[i]`와 같이 초기화한다.
- 최적의 값을 찾을 때 앞과 뒤에 어떤 값에 먼저 곱 할지를 선택해야 하는데 선택방법은 다음과 같다.
  - 예를 들어 `dy[1][2]`의 값을 찾아야 할 때 앞전에 이미 구한 `dy[1][1], dy[2][2]`의 값을 가지고 선택하면된다.
  - 선택방법은 `dy[1][1] = 1, dy[2][2] = 3`의 값이라고 했을 때, `dy[1][1] + (nums[1] + nums[2])` 값과 `dy[2][2] + (nums[1]+ nums[2])`) 값 중 더 큰 값을 `dy[1][2]`에 값을 넣어준다.
    - `dy[1][1] + (nums[1] + nums[2])` 이런 방식으로 구하는 이유는 `dy[1][1] = 1, nums[1] = 1, nums[2] = 3` 일 때 변수를 풀이하면, `1 + 1 + 3`가 되고, 결국 `1 x 2 + 3 x 1`이 되기 때문에 문제에서 제시한 `v(i) x k`의 값이 구해진다.
    - `dy[2][2] + (nums[1] + nums[2])`은 `3 x 2 + 1 x 1`이 되고 `Math.max(5, 7)`로 비교했을 때 `7`이 더 크기 때문에 `dy[1][2]`에는 `7`이 저장되게 된다.
- 마지막으로 `dy[1][N]`을 반환하면 정답이 노출된다.

<br/>

## 문제점