# [청소](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap1/stap1-2/src/Main.java)

방 정보인 n x n 크기의 board 값이 주어지고 1이 벽으로 막혀있다고 했을 때 청소로봇이 1을 피해 방향전환을 하며 카운트(k) 만큼 움직였을 때의 최종 좌표를 구하는 문제이다. ( 이때 방향전환을 했을 때 카운트 1 감소한다. ) <br/>

## 내가 푼 방식
* 첫 번째: k 카운트 값을 1 증가시켜 반복문을 준비한다. k 카운트 증가 이유는 0,0 좌표부터 시작하기 때문에 시작위치 값을 빼주기 위해서다.
* 두 번째: 반복문을 돌며 카운트가 감소하고 다음 좌표 값으로 이동하려 할 때 다음 좌표 값이 벽으로 막혀 있지 않고, board의 크기에도 벗어 나지 않으면 이동할 수 있다고 판단하여 이동로직을 종료한다.
* 세 번째: board의 크기에 벗어나거나 벽에 가로 막혀있다면 카운트를 감소 시키고 90도 회전시켜 회전시킨 좌표 값을 또 비교하여 반복한다.
* 네 번째: 로봇 위치 값 pos가 방향전환 값 보다 커지면 0으로 초기화 하고, 초기 위치 기준으로 360도 회전 했는데도 다음위치가 정해지지 않거나 k 카운트가 0이 되면 현재 자표 값을 저장 후 완전 종료한다.
<br/>

## 강의
* 첫 번째: count 값을 하나 생성한다.
* 두 번째: 반복문을 도는데 count 가 k 카운트 값 보다 작을 때 까지 반복하고 반복문이 돌때마다 count 값을 증가 시킨다.
* 세 번째: 다음 좌표 이동 값을 확인하는데, 0 보다 작거나 board 크기 보다 크거나 벽에 막혀있을 때 방향전환 값을 계산 후 continue 이동이 가능하다면 좌표 값을 이동시킨다.
<br/>

## 차이점
* 첫 번째: 단순하게 회전 값 pos의 길이를 비교해서 0으로 초기화하거나 값을 못 찾았을 때 종료하도록 만들어서 불필요한 코드가 많았지만 강의에서는 pos의 값을 360 / 90 으로 총 4 방향을 움직을 수 있기 때문에 pos % 4 로 깔끔하게 값을 구해 불필요한 코드를 줄였다.