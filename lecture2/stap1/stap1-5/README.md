# [최대길이 바이토닉 수열](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap1/stap1-5/src/Main.java)

nums의 값이 주어지면 가장 길이가 긴 바이토닉 수열 개수를 출력하는 문제이다.<br/>

## 내가 푼 방식
* 첫 번째: 먼저 시작위치 인덱스(idx)인 0 변수를 할당한다.
* 두 번째: idx 부터 nums.length - 1 보다 작을 때 가지 반복문을 반복한다.
* 세 번째: 먼저 nums[idx] == nums[idx + 1] 을 비교해 만약 같다면 더 이상 바이토닉 수열이 아니므로 idx는 다음으로 증가 시키고 카운트가 3 이상일 경우 answer에 answer와 cnt를 비교해 더 큰 값을 넣어준다. 이때 cnt가 3 미만일 경우는 answer에 넣어주지않는데 이유는 바이토닉 수열은 문제기준으로 무조건 3 이상이기 때문에 넣지 않는다.
* 네 번째: nums[idx] == nums[idx + 1] 아닐 경우 nums[idx] < nums[idx + 1]을 비교 해준다.
* 다섯 번째: 만약 flag가 true 일 경우 answer에 값을 비교 후 갱신해주고 flag는 false로 변경, cnt는 1로 초기화 해준다. flag 값을 확인 후 값을 초기화 해주는 이유는 ‘1, 2, {1}, {2} ‘ 값이 있을 때 1, 2, 1’ 수열을 모두 지난 후 다음 값을 비교할 때 ‘{1},{2}’ 다음 위치가 현재 위치보다 값이 클 경우 새로운 바이토닉 수열을 만난거기 때문에 값을 초기화 해 준다.
* 여섯 번째: nums[idx] > nums[idx + 1] 일 경우 flag 값을 true로 변경 해 준다.

<br/>

## 강의
* 첫 번째: 먼저 nums의 값에서 바이토닉 수열의 봉우리 값의 index를 배열에 저장한다.
* 두 번째: 봉우리 값이 저장되어 있는 배열을 기준으로 반복문을 돈다.
* 세 번째: 배열 값을 center 값으로 기준을 잡은 후 center 값을 기준으로 왼쪽으로 값을 비교해 cnt를 늘려 나간다.
* 네 번째: center 값을 기준으로 오른쪽으로 값을 비교해 cnt를 늘려 나간다.
* 다섯 번째: 마지막으로 비교가 끝났다면 answer에 값을 비교해 더 큰 수를 answer에 넣어준다.
<br/>

## 차이점
* 첫 번째: 나는 nums를 기준으로 한번에 값을 비교해나가 cnt를 초기화 해 줬다면, 강의에서는 봉우리의 값을 기준을 먼저 저장하고 그 봉우리 기준 값으로 cnt를 계산해 문제를 풀어 나갔다.