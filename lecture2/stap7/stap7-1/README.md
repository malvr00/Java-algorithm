# [타일 점프](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap7/stap7-1/src/Main.java)
현수의 집에서 상점까지는 자연수가 적혀있는 타일이 깔려있습니다. i번째 탈일에 적힌 수를 Ai라고 한다면 현수는 i번째 타일 위에서 오른쪽으로 Ai이하만큼 점프할 수 있습니다.<br/>
예를 들어 현수가 2번째 탈일에 있고, 적힌 수가 3이라면 현수는 3, 4, 5번째 타일로 점프할 수 있다.<br/>
현수가 집에서 상점까지 최소 몇 번의 점프로 갈 수 있는지 구하는 프로그램을 작성하세요. 매개변수 nums에 현수에 집에서부터 상점까지 차례대로 타일에 적힌 수가 주어집니다. 왼쪽 첫 번째 타일이 현수의 집이고, 오른쪽 끝 타일이 상점이라고 간주합니다.<br/>
만약 현수가 상점까지 갈 수 없다면 -1를 반환하세요.
<br/>

## 내가 푼 방식
- BFS 탐색을 시작하기 전에 먼저 인덱스 '0' 번과 타일 정보가 있는 nums의 첫 번째 점프 값을 큐에 넣는다.
- BFS 탐색을 진행할 때마다 카운를 1씩 증가시킨다.
- 큐.size() / 2 만큼 탐색 범위를 정해여 BFS 탐색을 한다.
- 큐에서 값을 poll() 한 후 첫 번째로 꺼낸 값은 nowIndex{현재 인덱스 번호}, nowTail{최대로 점프한 타일 번호}로 초기화 한다.
- nowTail이 nowIndex보다 작을 때 까지 탐색을 진행한다.
  - 만약 nowTail이 nums의 길이보다 클 경우 continue --> continue 하는 이유는 점차 감소하기 때문
  - nowTail이 nums.length() - 1 길이와 같다면, answer를 정답으로 반환한다.
- 큐에 '감소한 nowTail 값을 새로운 인덱스로', 'nums[nowTail] + nowTail 값은 새로운 최대 타일 번호'로 저장한다.
- 탐색이 종료되고 큐에 만약 값이 없다면, 점프할 수 있는 타일이 없기 때문에 '-1'을 반환한다.
<br/>

## 강의
- BFS 탐색 전 큐에 자기 집 좌표 0을 저장한다. 그리고 중복 탐색을 제거하기 위해 ch 배열에 ch['현재 좌표 인덱스']의 값을 1로 초기화한다.
- 큐에 들어있는 값 만큼 BFS 탐색을 nums['poll()'] 크기 만큼 진행한다.
- poll() + 현재 타일 위치 'i'를 큐에 저장한다.
- 저장하기 전에 현재 타일 위치를 ch에 1로 초기화하고, 만약 현재 타일 위치가 nums.length() - 1 크기와 같다면 answer를 1 증가 후 반환한다.
- BFS 탐색도중에 값을 반환하지 않았다면, '-1'을 반환한다.
<br/>

## 차이점
- 강의에서는 ch[] 배열 값을 할당해서 중복 탐색 범위를 줄여서 내가 푼 방식보단 탐색범위가 작다.
  - 내가 푼 방식에도 도입한다면, 많은 탐색 값을 줄일 수 있을 것 같다.