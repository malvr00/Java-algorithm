# [숲속의 기사](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap7/stap7-6/src/Main.java)
영희는 이 숲의 지도를 갖고 있다. 이 숲은 R * C의 판 형태의 크기로 되어 있다.</br>
이 지도에는 영희가 시작하는 위치, 기사가 서 있는 위치, 산딸기가 존재하는 위치 등이 표시 되어 있다. 또한 영희가 가지 못하는 위치도 표시되어 있다. 영희는 산딸기가 없이는 기사를 지나쳐 갈 수 없다.</br>
영희는 동,서,남,북 4방향으로만 움직일 수 있고, 하루에 한칸 씩 움직일 수 있다. 영희는 항상 산딸기를 기사에게 가져다 줄 수 있다.</br>
매개변수 board에 숲의 지도 정보가 주어지면 영희가 산딸기를 기사에게 가져다주는 가장 짧 은 날 수를 반환하는 프로그램을 작성하세요.

<br/>

## 내가 푼 방식
- 먼저 board에서 영희 위치와 기사 위치를 찾는다.
  - 영희와 기사 위치를 찾으면서 board 크기의 answerBoard와 copyBoard를 만드는데 answerBoard는 Integer.MAX_VALUE로 초기화하고, copyBoard는 영희 위치만 '0' 나머지는 board의 값을 복사한다.
- BFS를 총 2번 탐색 할 건데, 먼저 산딸기의 위치를 board를 기반으로 BFS 탐색을 진행한다.
  - 산딸기 위치를 찾으면, 산딸기를 배열에 저장하고 answerBoard 산딸기 위치에 이동횟수로 초기화한다.
- 2 번째 BFS 탐색에서는 저장된 산딸기 위치 배열을 기반으로 탐색을 진행하는데, copyBoard가 '1'이 아닐경우 값을 저장한다.
  - 이때 answerBoard[탐색 베이스 위치][탐색 베이스 위치] + 1 값이 answerBoard[다음 위치][다음 위치]보다 작을 경우에만 큐와 answerBoard에 값을 저장한다.
- 탐색이 모두 종료되면 answeBoard[기사위치][기사위치]로 정답을 반환한다.
<br/>

## 강의
- board를 기준으로 BFS 탐색을 2번 진행한다.
- 탐색 전 dist에 움직임 횟수 값을 누적할 2 차원 배열을 만든다.
- board의 값이 2 또는 3 일 경우 이동한 곳을 확인 할 체크 배열을 하나 만들고, 영희 또는 기사의 위치를 베이스로 BFS를 탐색한다.
  - board가 '1'이 아닐경우, 지나온 길을 board의 값이 아니라 체크배열의 값을 '1'로 만들어 벽을 세운다.
- 탐색하면서 지나온 길이아니거나 벽이 아닐경우에 움직인 카운트를 dist에 누적해 저장한다.
- 탐색이 모두 완료되면, dist에 저장된 배열을 탐색하는데, 이때 board의 값이 '4' 이면서 dist의 값이 '0'보다 큰 값들 중 가장 작은 값을 answer에 저장 후 반환한다.
<br/>

## 차이점
- 내가 푼 방식은 산딸기의 위치를 먼저 찾고, 산딸기 위치에서 이동한 최소 값들을 배열에 누적하면서 진행한 반면, 강의에서는 영희와 기사를 기준으로 이동한 값들을 전부 누적해나갔다.
  - 내가 푼 방법과, 강의 중 어떤 방식이 더 BFS 탐색을 적게하는지는 테스트를 해봐야 알 것 같다.