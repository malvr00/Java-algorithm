# [집을 짓자](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap7/stap7-5/src/Main.java)
n*n크기의 격자모양의 지도정보가 주어집니다.<br/> 
현수는 이 지도에서 모든 빌딩에서 이동거리의 합이 최소가 되는 빈땅 지점에 집을 짓고 싶습 니다. 이동은 상하좌우 인접한 빈땅으로만 이동합니다. 이동거리는 이동 횟수를 의미합니다.<br/>
현수의 집과 각 빌딩의 이동거리의 총합의 최소값을 반환하는 프로그램을 작성하세요.<br/>
모든 빌딩과 연결된 빈땅이 없다면 -1를 반환합니다.<br/>
1) 1은 빌딩을 의미합니다.
2) 2는 장애물을 의미합니다.
3) 0은 빈땅을 의미합니다.
<br/>

## 내가 푼 방식
- 먼저 빌딩의 개수를 알아낸 후 빌딩의 개수 만큼 지도정보를 새롭게 만든다.
- BFS 탐색을 시작하면서 현재 빌딩위치에서 상하좌우를 기준으로 탐색을 진행하는데, 이때 기존 지도정보와 새롭게 만든 지도정보의 값이 0 일 경우면 새로운 지도에 카운트를 누적한다.
- 빌딩 개수 만큼 BFS 탐색을 완료 했다면, 새로운 지도정보에 [0][0] 좌표부터 [마지막 번호][마지막 번호] 까지 차례로 값을 합해 최소 값을 반환한다.
  - 만약 만난적이 한번도 없다면 -1을 반환하도록 만든다


<br/>

## 강의
- 지도에서 빌딩의 위치를 찾으면 BFS 탐색을 시작한다.
- 지도탐색에 카운트를 누적할 배열을 하나 만들고, 빌딩위치를 기준으로 상하좌우 값을 누적한다.
  - 이때 지도에 값이 emptyLand와 같을 경우만 큐와 카운트 지도에 값을 저장한다.
    - emptyLand는 빌딩위치 한 사이클을 돌때 공통으로 탐색한 길을 알 수 있게 해준다.
- 마지막으로 카운트 지도배열에서 최소 값을 answer에 저장해서 반환한다. 이때 answer의 값이 변화가 없다면 -1을 반환한다.

<br/>

## 차이점
