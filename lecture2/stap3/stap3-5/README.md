# [cpu 스케쥴링](https://github.com/malvr00/Java-algorithm/blob/master/lecture2/stap3/stap3-5/src/Main.java)
tasks 배열 안에 작업을 처리해야하는 자원들이 순서 대로 들어있고, 각 작업은 [호출시간, 실행시간]으로 정보가 표현된다. tasks에 0번 작업부터 순서대로 각 작업의 정보가 주어지면 cpu가 처리하는 작업의 순서대로 작업번호를 배열에 담아 반환하는 프로그램을 작성하면 된다.

<br/>

## 내가 푼 방식
- 문제를 읽어보면 '실행시간이 가장 작은 작업을 먼저 처리하고, 같은 작업의 경우는 작업번호가 작은 것을 먼저 처리'라는 규칙이 있기 때문에 우선순위 큐를 활용한다.
- 인덱스, 호출시간, 실행시간을 저장하는 Node라는 클래스를 만든다. 그리고 우선순위 큐의 정렬 규칙을 Comparable<>을 상속받아서 정의한다.
- tasks의 값들을 호출시간을 key 값으로, Node는 value 값으로 Map에 저장한다.
- sec로 시간을 카운트를해서 각 작업시간에 맞는 값을 Map에서 꺼내와 우선순위 큐에 저장한다.
- 우선순위 큐에 값이 있다면, 값을 하나 꺼내 answer에 저장한다.

<br/>

## 강의
- tasks의 값을 LinkedList에 저장 후 호출시간을 기준으로 정렬한다.
  - 초기 작업은 0초부터 시간을 기준으로 하기 때문에 호출시간으로 정렬해준다. 
- 우선순위 큐도 규칙에 맞게 정렬순서를 정의한다.
- 우선순위 큐에 값이 없을 때 마지막 작업 시간을 체크하는 'fT' 값에 LinkedList 첫 번째 값의 호출 시간을 넣는다.
  - 이렇게 할 경우 첫 번째 작업을 찾거나, 현재 작업시간에 작업할 값이 없을 경우 바로 작업할 수 있는 값을 찾을 수 있다.
- LinkedList에 첫 번째 값의 작업시간이 'fT' 값 보다 같거나 작을 경우 우선순위 큐에 값을 저장한다.
- 우선순위 큐에서 값을 하나 꺼내온 후 'fT' 값에 꺼내온 값의 실행시간을 더해 현재 작업진행 시간을 초기화 해준다.
- 마지막으로 꺼내온 값의 작업순서를 answer에 저장한다.


<br/>

## 문제점
- 내가 푼 문제방식은 작업할 값을 찾지 못하면, 1초씩 흘러가기 때문에 만약 처음 작업이 9999초에 있을 경우 9999초 동안 무의미하게 반복문이 반복된다.
  - 위와 같은 문제로 작업할 값을 효율적으로 찾는 방법을 찾아야한다. 
