# [미로탈출](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level2/stap3/src/Main.java)

1x1 크기의 미로에서 탈출 하는 문제다. 탈출 하기 위에서는 미로에 레버를 먼저 당긴 후 탈출구를 통해 탈출 할 수 있고, <br/> 
탈출구를 먼저 도착해도 레버를 당기지 않으면 탈출 할 수 없는 문제이다.<br /> 
미로를 최대한 빠르게 빠져나가는 값을 구하는 문제 이기때문에 BFS를 사용하여 문제를 풀어나갔다. <br/>
<img src="https://github.com/malvr00/Java-Study/assets/77275513/4b3673bd-91a0-4547-8c18-de7cd8764c53" width="600px" height="300px" 
  title="100px" alt="RubberDuck"></img><br/>
<img src="https://github.com/malvr00/Java-Study/assets/77275513/8be4cb98-1378-46ae-a592-0b78ff6ba1ae" width="600px" height="300px" 
  title="100px" alt="RubberDuck"></img><br/>
  
## 해법
* 첫 번째로 미로에서 벽이 아닌 길을 지나 갈 경우 모두 ‘X’ 표시로 바꿔 벽으로 만들어 주었다. <br/>
* 두 번째로 이 문제는 목표지점이 레버, 탈출구 2가지 이기때문에 BFS를 2번 호출하여 천천히 풀어나갔다. <br/>
* 세 번째로 시작 위치부터 레버까지의 거리를 카운트시켜 주고, 만약 레버를 찾는데 찾을 수 없다면 -1이 호출 되어 그대로 정답으로 출력되게 만들어 줬다. <br/>
  레버를 찾았다면 지나오면서 벽으로 만들었던 미로를 다시 원래대로 돌린 후 현재까지 구한 거리를 반환한다. <br/>
* 네 번째로 레버까지의 거리 값을 찾았다면, 마지막으로 레버의 위치부터 탈출구까지의 거리를 찾았다. <br/>
  하지만 레버는 찾았지만 탈출구가 벽으로 막혀 있다면, -1이 호출되어 그대로 정답으로 출력되게 만들었고, <br/> 
* 그게 아니라면 앞에서 먼저 구했던 레버까지의 거라와 레버에서 탈출구까지의 거리를 합 해준 값을 정답으로 출력되게 만들었다.<br/>

## 문제점
* 첫 번째 시도: BFS를 한 번만 돌려 레버를 당긴 후 탈출구 까지 바로 갈 수 있도록 구현을 했는데, <br/> 
  레버까지 가는 도중 탈출구를 지나쳐왔다면, 다시 탈출구로 갈 방법이 없기때문에 실패했다.<br/>
* 두 번째 시도: BFS 한 번만 돌리던 걸 두 번 돌려서 레버까지의 거리, 레버에서 탈출구까지의 거리를 구하는 방식으로 변경했다.<br/> 
  먼저 레버에 도착하면 미로를 초기화 하고 레버에서 탈출구까지의 거리를 구했는데,  미로를 초기화하는 과정에서 문제가 발생했다.<br/> 
  미로 초기화까지는 문제가 되지 않았지만, 이미 레버를 찾았음에도 불과하고 상하좌우를 계속 탐색 하고있어서 <br/> 
  미로를 초기화 후에 반복문이 종료되었어야 했는데 종료되지않아 초기화한 미로에 다시 벽을 세우는 문제가 발생하여 실패했다. <br/>
* 세 번째 시도: 미로 초기화 후 반복문이 종료되지 않던 문제를 초기화 후 flag 값을 세워 바로 종료되도록 만들어 준 후 성공했다. <br/>
