# [등굣길](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step31/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/42898)) <br/>
가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.<br/>
<br/>
격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.

## 해법
* `puddles`에 저장되있는 좌표 값을 체크 배열 `ch`에 `TRUE`로 변환해준다.
* `m x n` 길이 만큼 만든 `board`를 마지막 `{m, n}` 좌표 까지 쭉 누적합을 진행한다.
  * 누적합 진행 하는 방식은 
    1. `ch[x][y]` 해당 좌표가 물 웅덩이 일 경우 `0`으로 `board[x][y]` 값을 초기화.
    2. 물 웅덩이가 아닐경우 `board[x][y - 1] + board[x - 1][y]` 의 값을 나눈 나머지 값을 `board[x][y]`에 저장한다.
* 마지막으로 `board[m][n]`을 정답으로 반환한다.

## 핵심
* `DP`를 활용해도되고, `BFS`를 활용해도 된다.
* 문제의 핵심은 `[x][y]`의 좌표에 `몇 개의 경우의 수가 도착했는가`가 중요하다.
* 문제에서 이동할 수 있는 경우의 수가 `오른쪽, 아래` 두 가지 경우 밖에 없기 때문에 빙 돌아가는 경우의 수는 존재하지 않는다. 그렇기에 무조건 최단 경로로 도착지점으로 모든 경로가 이동된다.
  * `[x][y]`에 도착할 수 있는 경우의 수는 `[x][y - 1], [x - 1][y]`의 경우의 수 밖에 존재하지 않는다.

## 문제점
* 이동경로가 `오른쪽, 아래` 두 가지만 존재할 경우 도착지점까지 이동하는 경로들이 모두 최소경로의 성격을 띄는것을 몰랐다.
  * 두 경로로만 이동하면 `왼쪽, 위` 이동을 진행하면서 중복 좌표이동이 없어져 이동하는 경로가 최단경로의 성격을 가지게된다.\binom{(m-1)+(n-1)}{m-1} 