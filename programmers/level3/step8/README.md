# [(KAKAO BLIND RECRUITMENT)표현 가능한 이진트리](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step8/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/150367)) <br/>
당신은 이진트리를 수로 표현하는 것을 좋아합니다.<br/>
이진트리를 수로 표현하는 방법은 다음과 같습니다.<br/>
1. 이진수를 저장할 빈 문자열을 생성합니다.<br/>
2. 주어진 이진트리에 더미 노드를 추가하여 포화 이진트리로 만듭니다. 루트 노드는 그대로 유지합니다.<br/>
3. 만들어진 포화 이진트리의 노드들을 가장 왼쪽 노드부터 가장 오른쪽 노드까지, 왼쪽에 있는 순서대로 살펴봅니다. 노드의 높이는 살펴보는 순서에 영향을 끼치지 않습니다.<br/>
4. 살펴본 노드가 더미 노드라면, 문자열 뒤에 0을 추가합니다. 살펴본 노드가 더미 노드가 아니라면, 문자열 뒤에 1을 추가합니다.<br/>
5. 문자열에 저장된 이진수를 십진수로 변환합니다.

## 해법
* 이진트리를 만들고 2 진수를 만들면 될 것 같은문제 같지만 이 문제는 2 진수를 먼저 만들고 역추적해서 풀어가도 되는 문제다
* 첫 번째 수를 2 진수로 변환한한다
* 구한 2 진수가 포화 이진트리를 만들기해 필요한 노드개수보다 부족 할 수 있기 떄문에 포화 이진트리를 만들 수 있는 최종 노드 개수를 구한다.
  * 이진트리는 2^n - 1 개로 만들어진다.
* 노드의 개수만큼 체크배열을 만든 후 2 진수와 비교해 2 진수의 값이 `1`인 경우 `TRUE`값을 저장한다.
* 값 초기화 완료 후 이진트리를 왼쪽 서브트리부터 탐색한다.
* 이진트리의 루트노드는 2 진수의 총 길이의 중간 값이 루트노드. 즉 `(startIndex + endIndex) / 2`
* 루트노드가 더미노드 즉 '0'이고, 자식 노드가 더미노드가 아닌 '1'일 경우 '0'을 리턴하고 종료
* 리프노드일 때 까지 재귀를 돌면서 다음 재귀 값에 `startIndex, endIndex, 현재 노드 루트노드 체크 값`을 넘긴다.
* 재귀가 끝나면 정답 배열에 재귀 결과 값 저장

## 핵심
이 문제는 먼저 2 진수를 먼저 만든 후 역추적 해 풀어도 되는문제다.<br/>
루트노드의 자식노드는 `mid`값을 기준으로 쉽게 알 수가 없으며, 자식노드가 더미 값 인지 아닌지 판단하기 위해서는 결국 리프노드까지 탐색해야한다 <br/>

## 문제점
문제를 이해하는데 오랜시간이 걸렸다. 문제를 이해하면 쉬운문제이지만 이해까지 너무 오래걸려 지문에서 답을 도출하는 핵심을 빠르게 찾아야겠다.<br/>
처음 쉽게생각해 `mid = 루트노드`이기 때문에 `mid - 1, mid + 1`의 값을 루트노드의 자식노드로 취급하고 문제를 풀어나갔는데 그림을 그려서 확인한 결과 형제노드가 될 수도 있기 때문에 트리문제는 애매할 때 트리를 직접 구현해보는게 속 편하다. 