# [보석 쇼핑(KAKAO)](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step22/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/67258)) <br/>
진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.<br>
가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다.

## 해법
* `Set`을 활용해서 주어지는 배열에서 찾아야하는 보석의 수를 찾는다.
* 투포인트를 활용하는데, 반복문을 돌면서 `HashMap`에 `endIdx` 부분부터 보석 값을 집어넣는다.
  * 이때 맨 처음으로 구매한 보석일 경우`(즉 map.get('...') == 1)` 탐색 개수를 1 증가 시킨다
    * 보석이 중복이 존재할 수 있기 때문에 최초로 구매한 보석의 값만 카운팅하도록 한다.
* 모든 보석을 구매했을 경우 탐색 개수가 이전에 구해놓은 탐색의 개수보다 작다면 해당 범위를 저장한다.
  * `startIdx, endIdx, '탐색 개수'`를 정답을 도출하기 위해 정답 변수에 저장한다.
* `gaems.length`의 길이만큼 반복문을 돌았다면 정답을 반환한다.

## 핵심
* 투포인트 알고리즘으로 시간복잡도를 `O(N)`으로만 탐색해 문제를 풀어야한다.  

## 문제점
* 윈도우 슬라이드로 탐색하는 방식으로 처음 문제를 해결하려 했으나, 최악의 경우 `O(N^2)` 까지 늘어나는 바람에 실패했다.