# [[PCCP 기출문제] 4번 / 수레 움직이기](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step3/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/250134)) <br/>
퍼즐판에는 빨간색 수레와 파란색 수레가 하나씩 존재합니다. 각 수레들은 자신의 시작 칸에서부터 자신의 도착 칸까지 이동해야 합니다. <br/>
모든 수레들을 각자의 도착 칸으로 이동시키면 퍼즐을 풀 수 있습니다.<br/>
<br/>
당신은 각 턴마다 반드시 모든 수레를 상하좌우로 인접한 칸 중 한 칸으로 움직여야 합니다. 단, 수레를 움직일 때는 아래와 같은 규칙이 있습니다.<br/>
<br/>
1. 수레는 벽이나 격자 판 밖으로 움직일 수 없습니다.<br/>
2. 수레는 자신이 방문했던 칸으로 움직일 수 없습니다.<br/>
3. 자신의 도착 칸에 위치한 수레는 움직이지 않습니다. 계속 해당 칸에 고정해 놓아야 합니다.( 모든 수레가 도착칸에 이동할 때 까지 )<br/>
4. 동시에 두 수레를 같은 칸으로 움직일 수 없습니다. ( 두 수레가 붙어있는 경우 )<br/>
5. 수레끼리 자리를 바꾸며 움직일 수 없습니다.

## 해법
* 두 수레가 도착한 최소 움직임을 찾아야했기 때문에 BFS 채택해 구현을 진행했다.
* 맨 처음 빨간 수레와 파란 수레의 시작지점을 찾아 `Node`에 저장한다.
  * `Node`와 같이 두 수레를 동시에 움직여야 하기 때문에 움직임 체크 배열을 재정의해서 같이 저장한다.
* 수레의 시작 위치 두 값을 찾았으면, `Queue`를 활용해 BFS 탐색을 시작한다.
* Queue 맨 앞에 처음 등록된 `Node`를 기준으로 탐색한다. (이를 `BaseNode`로 정의한다.)
* `BaseNode`를 기준으로 탐색을 진행하는데, 이때 `BaseNode`의 탐색이 종료 됐을 때, 다음 수레를 `BaseNode`로 변경해서 재탐색할지 정한다.
  * 재탐색하는 이유는 맨 처음 선택한 `BaseNode`로 계속 탐색을 할 경우 두 수레가 같이 붙어있는 상황이 생길 때 문제가 발생할 수 있다.
    * 만약 `[[1,2,0], [0,0,0], [3,0,4]]` 이런 맵이 주어졌을 때 빨간 수레는 `[0][1]` 위치로 이동을 할 수 없는데 파란 수레를 먼저 움직일 경우 파란 수레는 `[0][2]`로 이동하고 그때서야 빨간 수레가 파란 수레 있던 위치로 이동이 가능하다.
      * 두 수레가 붙어있는 상황만 재탐색을 한다면, 실행 속도를 크게 줄일 수 있고, 탐색하지 않는 경우의 수는 없어진다. 
    * 파란 수레를 먼저 이동하는 경우를 빼고 BFS 탐색을 진행할 경우에는 파란 수레를 기준으로 탐색을 했을 때, 빨간 수레의 기준으로 탐색한 것 보다 더 빨리 도착할 수 있기 때문에 빨간 수레의 기준만으로는 '최소 도착' 조건에 부합하지 않을 수 있다.
* 빨간 수레와 파란 수레가 모두 도착한다면 탐색을 종료한다.

## 문제점
동시에 수레를 움직일 경우 빨간색 수레가 먼저 움직였을 때, 파란색 수레가 먼저 움직였을 때 두 가지를 모두 생각해줘야한다. <br/>
빨간색 수레만 이동해서 결과가 안나온다면, 파란색 수레를 먼저 이동해야 하는 경우를 찾아 파란색 수레도 이동시켜줘야한다.

