# [경주로 건설(KAKAO)](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step21/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/67259)) <br/>
제공된 경주로 설계 도면에 따르면 경주로 부지는 N x N 크기의 정사각형 격자 형태이며 각 격자는 1 x 1 크기입니다.<br/>
설계 도면에는 각 격자의 칸은 0 또는 1 로 채워져 있으며, 0은 칸이 비어 있음을 1은 해당 칸이 벽으로 채워져 있음을 나타냅니다.<br/>
경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다.<br/>
경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다.<br/>
이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 직선 도로 라고 합니다.<br/>
또한 두 직선 도로가 서로 직각으로 만나는 지점을 코너 라고 부릅니다.<br/>
건설 비용을 계산해 보니 직선 도로 하나를 만들 때는 100원이 소요되며, 코너를 하나 만들 때는 500원이 추가로 듭니다.<br/>
죠르디는 견적서 작성을 위해 경주로를 건설하는 데 필요한 최소 비용을 계산해야 합니다.

## 해법
* BFS로 문제를 풀어 나갈껀데, 먼저 4 방향 체크배열을 최대 값으로 초기화한다.
  * 시작지점의 4 방향은 '0'으로 초기화한다. (이를 ch로 정의한다)
  * 4 방향으로 배열을 만들어서 확인하는 이유는 `[x][y]`위치를 두고 `[0][1] -> [0][2] -> [1][2]`와 `[1][1] -> [1][1] -> [1][2]`으로 이동되는 두 값을 비교할 때 `코너`를 만들고 온 도로는 제외될 위험이있다.
    * `코너`가 생성될 때 제외가 된다면 왜 문제가 되냐면, `코너`를 만들고 온 도로가 도착지점까지 갔을 때 `최소 비용`의 도로가 될 수 있기 때문에 제외되면 안된다.
* 탐색을 시작하면서 `Queue`에서 꺼낸 노드`(cur)` 값을 가장 먼저 `cur.cost > ch[cur.x][cur.y][cur.d]` 값을 비교 후 '참'이면 다음 노드를 탐색한다.
  * `cur.cost > ch[cur.x][cur.y][cur.d]`의 이유는 이게 '참'일 경우의 수는 해당 위치에 이미 최소 가중치 값이 먼저 지나갔기 때문에 현재 노드가 이 보다 크다면 탐색에서 제외시켜도 된다.
* 이후 벽과 보드 범위를 벗어나지 않는 범위와 `새로 만든 도로의 값`이 `ch[nX][nY][j]`의 값보다 작다면 해당 도로는 `최소 값의 도로`이기 때문에 해당 노드를 저장한다.
* 마지막으로 체크 배열의 마지막 지점 4 방향 중 가장 작은 값을 반환한다.

## 핵심
* 체크 배열을 4 방향을 만들어서 관리하는게 가장 중요하다.
* 새로 생성하려는 도로가 생성하려는 위치에 최소 비용의 도로인지를 판단해서 경우의 수를 줄여 탐색 범위를 좁혀줘야한다.

## 문제점
* 맨 처음 `board`를 완전복사 방식으로 노드와 함께 저장한 후 새로 탐색할 때 마다 해당 `board`를 완전복사해서 계속 새로운 노드를 생성했는데, 이렇게 할 경우 메모리 초가와 시간초과가 발생했다.
  * 해당방식으로 `board`를 계속 생성한다면 `총 탐색 상태 수(최악 O(N²)개) × O(N²) → O(N⁴)`가 되기때문에 결국 폭발해버린다.
  * 완전복사 방식이 값을 구하는데 편하지만 해당 방식으로 효율이 좋지 않다면 `하나의 체크배열`을 만들어서 효과적으로 관리하는 방법을 연습해야겠다.