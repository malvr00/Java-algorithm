# [카운트 다운](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step11/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/131129)) <br/>
프로그래머스 다트 협회에서는 매년마다 새로운 특수 룰으로 다트 대회를 개최합니다. 이번 대회의 룰은 "카운트 다운"으로 "제로원" 룰의 변형 룰입니다.<br/>
"카운트 다운"은 게임이 시작되면 무작위로 점수가 정해지고, 다트를 던지면서 점수를 깎아서 정확히 0점으로 만드는 게임입니다. 단, 남은 점수보다 큰 점수로 득점하면 버스트가 되며 실격 합니다.

## 해법
* 목표 점수 즉 `target`까지 dy 배열을 만들어서 DP 알고리즘을 실행한다.
* 목표 점수 `1점 ~ target`까지 누적해 나가는 방향으로 로직을 구현해야한다.
  * 예를 들어 목표 점수가 `2 점`이고, 현재 맞춘 점수가 `1 점`일 경우
    * 먼저 `싱글`을 타격했을 때의 다트 개수를 `[i - hit][0] + 1` 값과 `[i][0]` 값을 비교 후 더 큰 값을 누적, `[i - hit][1]`에 싱글 맞춘 횟수를 1 증가 한다.
    * 더블, 트리플 모두 싱글과 같은형식
    * 위와 같은 형식으로 `dy`의 값을 누적해 나갈 때 `dy[i][0]`의 값은 `i`를 맞추기 위한 최소한의 다트 소모 개수가 저장된다.
* 마지막으로 `dy[target][0]`과 `dy[target][1]`을 answer에 저장 후 반환

## 핵심
`dy[i][j]`에 `[i]` `[j]`를 정의하는 것이 가장 중요하다.

## 문제점
DP의 냅색 알고리즘까지는 생각했지만 싱글, 더블, 트리플, 불 형태의 각각의 최적의 점수를 어떻게 저장할 지 오래걸렸다. 
