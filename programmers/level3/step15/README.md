# [표 편집 (2021 카카오 채용연계형 인턴십)](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step15/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/81303)) <br/>
한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다.<br/>
"U X": 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다.<br/>
"D X": 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다.<br/>
"C" : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다.<br/>
"Z" : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다.


## 해법
* 이중 연결할 배열 2 개를 생성한다.
  * `prev, next` 연결할 이전 인덱스 값, 연결할 다음 인덱스 값 배열 2 개 생성
    * `prev -> prev[i]은 = i - 1, next -> next[i] = i + 1`
      * 이렇게 될 경우 `0`번 인덱스가 왔을 때 `prev[0] = -1, next[0] = 1`로 기준 `0` 으로 서로 연결된 모습을 보여준다.
* `cmd`의 값이 `U 또는 D` 일 경우 그 횟수 만큼 반복문을 돌며 `k` 값을 구한다.
* `cmd`의 값이 `C` 일 경우 해당 `k` 값의 행을 지우고 `prev, next`에서 `k`의 값을 삭제해 `prev -> cur -> next` 모습에서 `prev -> next`의 모습으로 연결시킨다.
* `cmd`의 값이 `Z` 일 경우 가장 최근에 삭제된 값을 꺼내와 `prev, next`에 `k` 값의 행을 추가해 다시 `prev -> cur -> next`의 모습으로 복구시킨다.
* 마지막으로 삭제된 행이 존재 할 경우 해당 인덱스만 `X`로 표기해준 후 반환한다. 

## 핵심
* `이중 연결 리스트` 방식을 활용해야 o(1)의 속도로 정답 도출이 가능하다.

## 문제점
* 자바에서 제공하는 연결 리스트만으로 해결을 시도했으나, 다음 인덱스 값을 찾는데에 문제와 o(N) 탐색 문제가 있어서 포기했다.
  * 제공하는 자료형을 사용하지 않고, 직접 연결 리스트를 구현하거나 메모리를 고려한다면 배열을 통한 배열 이중 연결 리스트를 활용해서 문제를 해결해야했다.