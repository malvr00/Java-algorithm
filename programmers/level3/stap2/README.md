# [n + 1 카드게임 (2024 KAKAO WINTER INTERNSHIP)](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step2/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/258707)) <br/>
당신은 1~n 사이의 수가 적힌 카드가 하나씩 있는 카드 뭉치와 동전 coin개를 이용한 게임을 하려고 합니다. 카드 뭉치에서 카드를 뽑는 순서가 정해져 있으며, 게임은 다음과 같이 진행합니다.<br/>
<br/>
1. 처음에 카드 뭉치에서 카드 n/3장을 뽑아 모두 가집니다. (n은 6의 배수입니다.) 당신은 카드와 교환 가능한 동전 coin개를 가지고 있습니다.
2. 게임은 1라운드부터 시작되며, 각 라운드가 시작할 때 카드를 두 장 뽑습니다. 카드 뭉치에 남은 카드가 없다면 게임을 종료합니다. 뽑은 카드는 카드 한 장당 동전 하나를 소모해 가지거나, 동전을 소모하지 않고 버릴 수 있습니다.
3. 카드에 적힌 수의 합이 n+1이 되도록 카드 두 장을 내고 다음 라운드로 진행할 수 있습니다. 만약 카드 두 장을 낼 수 없다면 게임을 종료합니다.
<br/>
## 해법
* 카드의 길이 최대길이가 1000이고, 카드를 뽑는 경우의 수가 `전부 선택 안함, 1 번 선택, 2 번 선택, 전부 선택` 이렇게 4 가지 경우이기 때문에 시간초과가 날 것 같아 DFS로는 풀지 않았다.
  * 'DP'로 풀이가 가능할까 했는데, 누적값 활용할 길이 없어 포기했다.
* 처음 손패 카드를 `n/3` 만큼 카드를 선택해 Set 변수에 저장한다.
  * Set 변수를 사용한 이유는 remove()를 편하게 활용하기 위함과, 카드 번호가 중복될 일이 없다고 문제에 나와있어 `List`가 아닌 `Set`을 채택했다.
* 이제 카드뽑기 게임을 진행하는데, 먼저 카드뭉치에서 카드 2 장을 내 손패가 아닌 별도의 `Set` 변수에 할당한다.
  * 내 손패가 아닌 별도의 변수에 저장하는 이유는 내가 선택안한 카드 패 들의 조합으로 `n+1`의 합이 나올 수 있기 때문에 필요할 때 코인을 추가로 사용해 카드를 제출한다.
    * 이렇게 되면 문제 풀이 방식을 어긴 것 같지만 최종적으로 뽑은 카드들을 나열하면 4 가지 경우의 수 중에 최적의 뽑기만 선택하게 된다.
* 해당 라운드에서 아래와 같은 방법으로 카드를 제출한다.
  * 1) 뽑은 카드 중 손 패 카드와 비교해 제출카드를 확인한다.
  * 2) 뽑은 카드들로 해결이 안될 을 때 손 패만을 확인해 제출할 수 있는지 확인한다.
  * 3) 손 패로도 제출을 할 수 없을 때는 카드는 뽑았지만 코인을 사용하지 않은 카드뭉치들을 확인한다.
  * 4) 3 가지 방법 모두 카드를 제출할 수 없을 때는 해당 게임을 종료한다.

## 문제점
구현문제가 익숙치 않아서 초반에 어떤 알고리즘을 선택할지 시간이 너무 많이 빼았겼다. <br/>