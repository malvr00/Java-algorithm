# [(2023 KAKAO BLIND RECRUITMENT) 미로 탈출 명령어](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step9/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/150365)) <br/>
n x m 격자 미로가 주어집니다. 당신은 미로의 (x, y)에서 출발해 (r, c)로 이동해서 탈출해야 합니다. <br/>
단, 미로를 탈출하는 조건이 세 가지 있습니다.<br/>
<br/>
격자의 바깥으로는 나갈 수 없습니다.<br/>
(x, y)에서 (r, c)까지 이동하는 거리가 총 k여야 합니다. 이때, (x, y)와 (r, c)격자를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다.<br/>
미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출해야 합니다.<br/>
이동 경로는 다음과 같이 문자열로 바꿀 수 있습니다.<br/>
<br/>
l: 왼쪽으로 한 칸 이동<br/>
r: 오른쪽으로 한 칸 이동<br/>
u: 위쪽으로 한 칸 이동<br/>
d: 아래쪽으로 한 칸 이동<br/>
예를 들어, 왼쪽으로 한 칸, 위로 한 칸, 왼쪽으로 한 칸 움직였다면, 문자열 "lul"로 나타낼 수 있습니다.

## 해법
* `BFS` 탐색 전 `상우좌하` 이동 할 때 마다 저장되는 문자를 미리 정렬시켜 저장한다.
  * 예를 들어 `상 = a, 하 = c, 좌 = b, 우 = d` 일 경우 `상 = a, 좌 = b, 하 = c, 우 = d` 이런식으로 정렬한다.
    * 이렇게 미리 정렬을 진행해 방향을 미리 정해 놓으면 탈출한 명령어들을 전부 수집 후 오름차순으로 정렬할 필요가 없다. 
* `Queue`에 시작 좌표를 저장 후 BFS 탐색을 시작한다.
* 탐색을 4 방향으로 이동하면서 `맨해튼 거리`로 도착지점까지의 최소거리르 구한 후 내가 이동한 거리와 값을 비교한다.
  * 다음 위치에서 도착지점까지 최단 거리를 구한 후 내 남은 이동거리를 비교하면 다음 위치에서 도착지점까지 갈 수 있을지 없을지 판단이 된다.
  * `최단 거리`가 만약 `남은 이동거리`보다 클 경우 도착 지점에 갈 수 없기 때문에 다음 방향을 탐색을 진행한다.
* 다음 위치로 이동이 가능하다면, `Queue`에 이동한 거리 값을 저장 후 방향탐색을 종료한다.
  * `Queue`에 저장하기까지 이미 `4 방향 중 최적의 거리, 이동 문자 오름차순 정렬` 작업을 해뒀기 때문에 `Queue`에 저장되는 값은 항상 `최단 거리` 문자열이다.
* 다음 위치가 도착지점이라면 정답을 출력한다. 

## 핵심
주어진 맵에서 가로막는 벽이 존재하지 않기 때문에 `맨해튼 거리` 공식을 활용할 수 있다.<br/>
`BFS` 탐색을 진행하면서 도착지점까지 도착이 불가능한 경우의 수 들은 모두 쳐내야한다. 그렇지 않으면 시간초과가 발생한다.<br/>
마지막으로 탈출한 명령어들을 마지막에 재정렬을 하지 않고 바로 출력시킬 수 있는 정렬효과를 보기 위해 위치 이동 문자열을 미리 정렬해두는게 중요하다.

## 문제점
BFS 탐색경로를 줄이는게 가장 큰 문제였다. 이 문제를 맨해든 거리 공식을 활용해서 줄이는 방법을 택했다. 