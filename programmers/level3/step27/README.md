# [여행경로](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step27/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/43164)) <br/>
주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 "ICN" 공항에서 출발합니다.<br/>
<br/>
항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.<br/>
<br/>
제한사항<br/>
모든 공항은 알파벳 대문자 3글자로 이루어집니다.<br/>
주어진 공항 수는 3개 이상 10,000개 이하입니다.<br/>
tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.<br/>
주어진 항공권은 모두 사용해야 합니다.<br/>
만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.<br/>
모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.<br/>

## 해법
* `tickets`를 전체를 탐색해야 하기 때문에 백트레킹 시 중복을 피하기 위해 체크배열을 추가한다.
* 지문에서 주워줬듯이 `ICN`을 기준으로 DFS 탐색을 진행한다.
  * 탐색 조건은 `방문한 곳이 아닐경우, 출발지가 존재할 경우`를 기준으로 탐색을 진행한다.
* `tickets`를 모두 탐색했다면, `정답 리스트`와 탐색하면서 저장한 `탐색 리스트`를 비교해 `탐색 리스트` 경로의 알파벳 순서가 더 앞설 경우 `정답 리스트`를 `탐색 리스트`로 교체한다.

## 핵심
* 주의사항에 나와 있듯이 주어진 항공권을 모두 사용해야한다. 즉 `tickets`를 모두 탐색해야한다

## 문제
* 처음 문제를 접근했을 때 `tikects`정보를 Map<String, ArrayList<>()> 형태로 저장하면서 값을 정렬해 Greedy+DFS로 탐색했으나 tikects를 모두 탐색하지 않는 로직이 탄생했다.
  * tickets를 전부 탐색하지 않는 문제가 있어 (value -> key 형태로 탐색) tikects를 중심으로 탐색을 진행해 문제를 해결했다.