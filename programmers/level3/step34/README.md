# [디스크 컨트롤러](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step34/src/Main.java)
하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 이 문제에서는 우선순위 디스크 컨트롤러라는 가상의 장치를 이용한다고 가정합니다. 우선순위 디스크 컨트롤러는 다음과 같이 동작합니다.<br/>
<br/>
어떤 작업 요청이 들어왔을 때 작업의 번호, 작업의 요청 시각, 작업의 소요 시간을 저장해 두는 대기 큐가 있습니다. 처음에 이 큐는 비어있습니다.<br/>
디스크 컨트롤러는 하드디스크가 작업을 하고 있지 않고 대기 큐가 비어있지 않다면 가장 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킵니다. 이때, 작업의 소요시간이 짧은 것, 작업의 요청 시각이 빠른 것, 작업의 번호가 작은 것 순으로 우선순위가 높습니다.<br/>
하드디스크는 작업을 한 번 시작하면 작업을 마칠 때까지 그 작업만 수행합니다.<br/>
하드디스크가 어떤 작업을 마치는 시점과 다른 작업 요청이 들어오는 시점이 겹친다면 하드디스크가 작업을 마치자마자 디스크 컨트롤러는 요청이 들어온 작업을 대기 큐에 저장한 뒤 우선순위가 높은 작업을 대기 큐에서 꺼내서 하드디스크에 그 작업을 시킵니다. 또, 하드디스크가 어떤 작업을 마치는 시점에 다른 작업이 들어오지 않더라도 그 작업을 마치자마자 또 다른 작업을 시작할 수 있습니다. 이 과정에서 걸리는 시간은 없다고 가정합니다.

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/42627#)) <br/>

## 해법
* 먼저 작업요청 값을 `요청시간 -> 작업시간 -> 요청번호` 순으로 오름차순 정렬을 진행한 후 `List`에 저장한다.
* 작업을 저장할 우선순위 큐를 만들어 `작업시간 -> 요청시간 -> 요청번호` 순으로 오름차순 정렬을 진행한 후 생성한다.
* 이제 작업요청이 모두 완료될 때 까지 반복문을 돌면서 탐색한다.
* `List`에서 현재 시간 `time`과 비교해서 `요청시간`이 더 작거나 같을 경우 우선순위 큐에 저장한다.
* 우선순위 큐에 저장된 값이 존재할 경우 다음과 같이 처리한다.
  * 우선순위 큐에서 작업을 꺼낸 후 `time`과 `요청시간`을 비교한 후 `time`이 더 작다면 `요청시간`으로 초기화한다.
  * `time`에 `작업시간`을 누적합을 진행한 후 `time`을 기준으로 정답 변수 `answer`에 `(time - 요청시간)` 만큼 계산한 결과를 합해준다.
  * 작업이 완료되면, 완료 카운트를 1 증가 시킨다.
* 우선순위 큐에 저장된 값이 존재하지 않을 경우 `time`과 `List.get(i)` 번째 요청시간을 비교한 후 더 큰 시간을 `time`에 초기화한다.
* 모든 작업이 완료되면 `answer / 작업 개수` 를 정답으로 반환한다.

## 핵심
* 작업시간이 다음 작업의 요청시간이 됐을 때 우선순위 큐에 저장하는게 중요하다.
  * 작업 요청시간이 안되었는데 우선순위 큐에 저장하고 대기시킨다면 치명적인 이슈가 발생한다.

## 문제점
* 작업요청 목록을 정렬 후 한번에 우선순위 큐에 저장한 다음 정답을 도출하려했으나 실패했다.