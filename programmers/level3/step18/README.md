# [거스름돈](https://github.com/malvr00/Java-algorithm/blob/master/programmers/level3/step18/src/Main.java)

([자세한 문제는 프로그래머스 참고](https://school.programmers.co.kr/learn/courses/30/lessons/12907)) <br/>
Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.<br/>
예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.<br/>
1원을 5개 사용해서 거슬러 준다.<br/>
1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다.<br/>
1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다.<br/>
5원을 1개 사용해서 거슬러 준다.<br/>
거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요.<br/>

## 해법
* DP 실행할 배열 생성.
* `dy[0] = 1`로 초기화한다.
* `money[i](coin)`을 기준으로 `money[i](coin) <= n` 반복문을 돈다.
* `dy[j]` 값을 구하려 할 때 `dy[j] + dy[j - coin]` 값을 `dy[j]`에 누적 합으로 진행한다.
  * `dy[j] + dy[j + coin]`의 의미는 만약 `j = 2`이고 `coin = 1`일 때 `dy[j - coin] = dy[1]`고 `dy[1]`은 `1 원을 만들 수 있는 모든 경우의 수`가 누적되어있고, 여기에 1 원을 더해 `dy[2]`를 구하는데 새로운 조합이 된다.
    * `dy[1] = {1}`이고 `dy[2]는 이전 모든 경우의 수에 1 을 더한 즉 {1 + (1)}`가 된다.
    * 예 2) `j = 4, coin = 2`일 때 `dy[4]`는 `dy[2] = {1 + 1, 2}`가 구해져잇고 모든 경우의 수에 2 를 더해 새로운 조합을 만들어낸다. `dy[4] = {1 + 1 + (2), 2 + (2)}` 
* 마지막에 `dy[n]`의 값을 반환한다.

## 핵심
* DP를 구현할 때는 인덱스 정의가 중요하다.
  * `j`는 현재 경우의 수를 구해야하는 코인
* 주어지는 돈으로 조합 할 수 잇는 경우의 수를 구해야하기 때문에 반복문을 `money[i]`를 기준으로 이중반복문을 돈다.

## 문제점
* 처음 문제를 해결하려 할 때 브루포스 방식을 사용했는데 효울성 테스트에서 시간초과가 발생.
  * 처음 풀어낸 방식이 틀렸을 때 빠르게 다른 방식을 선택해 문제를 해결할 수 있는 능력을 길러야겠다.